From 57b6e5afb6265363ede667ad450e267f8a803b9e Mon Sep 17 00:00:00 2001
From: Mark Reynolds <mreynolds@redhat.com>
Date: Wed, 19 Apr 2017 13:37:10 -0400
Subject: [PATCH] Ticket 48864 - Add cgroup memory limit detection to 389-ds

Bug Description:  Previously our memory limits only check hardware
    limits and shell resource limits. However, we may be in a container
    like docker or lxc, and unable to detect these limits. This can lead
    to crash conditions or worse, especially with autosizing
    on import we may have conditions where the server may not
    even be able to install.

Fix Description:  Add support for cgroup memory limit detection
    so that we can properly determine our resource availability regardless
    of lxc, docker, systemd or others.

https://pagure.io/389-ds-base/issue/48864

Author: wibrown

Review by: mreynolds (Thanks!)
---
 Makefile.am                                        |   7 +-
 ldap/servers/plugins/acl/acl.c                     |  18 +-
 ldap/servers/plugins/acl/acl.h                     |  16 -
 ldap/servers/plugins/acl/aclanom.c                 |   8 +-
 ldap/servers/plugins/dna/dna.c                     |  50 ++-
 ldap/servers/plugins/posix-winsync/posix-winsync.c |   4 +-
 ldap/servers/plugins/replication/repl.h            |  17 +-
 .../plugins/replication/repl5_inc_protocol.c       |   2 +-
 ldap/servers/plugins/replication/repl5_init.c      |   2 +-
 ldap/servers/plugins/replication/repl5_plugins.c   |   2 +-
 ldap/servers/plugins/replication/repl5_replica.c   |   8 +-
 ldap/servers/plugins/replication/repl5_total.c     |   4 +-
 ldap/servers/plugins/replication/repl_connext.c    |  20 +-
 ldap/servers/plugins/replication/repl_extop.c      |  26 +-
 ldap/servers/plugins/sync/sync_persist.c           |   6 +-
 ldap/servers/plugins/syntaxes/validate_task.c      |   6 +-
 ldap/servers/plugins/usn/usn.c                     |   8 +-
 ldap/servers/slapd/abandon.c                       |   8 +-
 ldap/servers/slapd/add.c                           |   4 +-
 ldap/servers/slapd/auth.c                          |  18 +-
 ldap/servers/slapd/back-ldbm/back-ldbm.h           |  23 +-
 ldap/servers/slapd/back-ldbm/cache.c               |  34 +-
 ldap/servers/slapd/back-ldbm/dblayer.c             |  72 ++--
 ldap/servers/slapd/back-ldbm/dblayer.h             |   8 -
 ldap/servers/slapd/back-ldbm/import-threads.c      |   2 +-
 ldap/servers/slapd/back-ldbm/import.c              |  12 +-
 ldap/servers/slapd/back-ldbm/ldbm_config.c         |  32 +-
 ldap/servers/slapd/back-ldbm/ldbm_delete.c         |   4 +-
 .../servers/slapd/back-ldbm/ldbm_instance_config.c |  20 +-
 ldap/servers/slapd/back-ldbm/ldbm_modrdn.c         |   4 +-
 ldap/servers/slapd/back-ldbm/ldbm_search.c         |   4 +-
 ldap/servers/slapd/back-ldbm/misc.c                |   2 +-
 ldap/servers/slapd/back-ldbm/monitor.c             |  10 +-
 ldap/servers/slapd/back-ldbm/perfctrs.h            |   2 +-
 ldap/servers/slapd/back-ldbm/start.c               | 113 +++----
 ldap/servers/slapd/bind.c                          |   8 +-
 ldap/servers/slapd/compare.c                       |   2 +-
 ldap/servers/slapd/connection.c                    |  72 ++--
 ldap/servers/slapd/conntable.c                     |   8 +-
 ldap/servers/slapd/control.c                       |   2 +-
 ldap/servers/slapd/daemon.c                        |  48 +--
 ldap/servers/slapd/delete.c                        |   2 +-
 ldap/servers/slapd/entry.c                         |   2 +-
 ldap/servers/slapd/extendop.c                      |   4 +-
 ldap/servers/slapd/log.c                           |  10 +-
 ldap/servers/slapd/modify.c                        |  12 +-
 ldap/servers/slapd/modrdn.c                        |   6 +-
 ldap/servers/slapd/monitor.c                       |   8 +-
 ldap/servers/slapd/operation.c                     |   6 +-
 ldap/servers/slapd/opshared.c                      |   4 +-
 ldap/servers/slapd/pagedresults.c                  |   2 +-
 ldap/servers/slapd/psearch.c                       |  10 +-
 ldap/servers/slapd/result.c                        |  12 +-
 ldap/servers/slapd/sasl_io.c                       |  52 +--
 ldap/servers/slapd/saslbind.c                      |   2 +-
 ldap/servers/slapd/search.c                        |   2 +-
 ldap/servers/slapd/slap.h                          |   9 +-
 ldap/servers/slapd/slapi-plugin.h                  |  14 +-
 ldap/servers/slapd/slapi-private.h                 |  38 ++-
 ldap/servers/slapd/slapi_pal.c                     | 311 +++++++++++++++++
 ldap/servers/slapd/slapi_pal.h                     |  62 ++++
 ldap/servers/slapd/snmp_collator.c                 |   2 +-
 ldap/servers/slapd/unbind.c                        |   6 +-
 ldap/servers/slapd/util.c                          | 376 +--------------------
 test/libslapd/spal/meminfo.c                       |  54 +++
 test/libslapd/test.c                               |   2 +
 test/test_slapd.h                                  |   5 +
 67 files changed, 870 insertions(+), 859 deletions(-)
 create mode 100644 ldap/servers/slapd/slapi_pal.c
 create mode 100644 ldap/servers/slapd/slapi_pal.h
 create mode 100644 test/libslapd/spal/meminfo.c

diff --git a/Makefile.am b/Makefile.am
index 485a460..429a345 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -481,6 +481,7 @@ dist_noinst_HEADERS = \
 	ldap/servers/slapd/pw_verify.h \
 	ldap/servers/slapd/secerrstrs.h \
 	ldap/servers/slapd/slap.h \
+	ldap/servers/slapd/slapi_pal.h \
 	ldap/servers/slapd/slapi-plugin-compat4.h \
 	ldap/servers/slapd/slapi-plugin.h \
 	ldap/servers/slapd/slapi-private.h \
@@ -850,6 +851,7 @@ pkgconfig_DATA = src/pkgconfig/dirsrv.pc \
 # header files
 #------------------------
 serverinc_HEADERS = ldap/servers/plugins/replication/repl-session-plugin.h \
+	ldap/servers/slapd/slapi_pal.h \
 	ldap/servers/slapd/slapi-plugin.h \
 	ldap/servers/plugins/replication/winsync-plugin.h \
 	src/nunc-stans/include/nunc-stans.h \
@@ -1219,6 +1221,7 @@ libslapd_la_SOURCES = ldap/servers/slapd/add.c \
 	ldap/servers/slapd/value.c \
 	ldap/servers/slapd/valueset.c \
 	ldap/servers/slapd/vattr.c \
+	ldap/servers/slapd/slapi_pal.c \
 	$(libavl_a_SOURCES)
 
 libslapd_la_CPPFLAGS = $(AM_CPPFLAGS) $(DSPLUGIN_CPPFLAGS) $(SASL_INCLUDES) @db_inc@ $(SVRCORE_INCLUDES) @kerberos_inc@ @pcre_inc@
@@ -2004,7 +2007,9 @@ test_slapd_SOURCES = test/main.c \
 	test/libslapd/counters/atomic.c \
 	test/libslapd/pblock/analytics.c \
 	test/libslapd/pblock/v3_compat.c \
-	test/libslapd/operation/v3_compat.c
+	test/libslapd/operation/v3_compat.c \
+	test/libslapd/spal/meminfo.c
+
 test_slapd_LDADD = libslapd.la
 test_slapd_LDFLAGS = $(AM_CPPFLAGS) $(CMOCKA_LINKS)
 ### WARNING: Slap.h needs cert.h, which requires the -I/lib/ldaputil!!!
diff --git a/ldap/servers/plugins/acl/acl.c b/ldap/servers/plugins/acl/acl.c
index 48b8efc..561dd91 100644
--- a/ldap/servers/plugins/acl/acl.c
+++ b/ldap/servers/plugins/acl/acl.c
@@ -276,7 +276,7 @@ acl_access_allowed(
 
 		 if (  !privateBackend && (be_readonly ||  slapi_config_get_readonly () )){
 			slapi_log_err(loglevel, plugin_name,
-				"acl_access_allowed - conn=%" NSPRIu64 " op=%d (main): Deny %s on entry(%s)"
+				"acl_access_allowed - conn=%" PRIu64 " op=%d (main): Deny %s on entry(%s)"
 				": readonly backend\n", 
 				o_connid, o_opid,
 				acl_access2str(access),
@@ -289,7 +289,7 @@ acl_access_allowed(
 	TNF_PROBE_0_DEBUG(acl_skipaccess_start,"ACL","");
 	if (  acl_skip_access_check ( pb, e, access )) {
 		slapi_log_err(loglevel, plugin_name,
-				"acl_access_allowed - conn=%" NSPRIu64 " op=%d (main): Allow %s on entry(%s)"
+				"acl_access_allowed - conn=%" PRIu64 " op=%d (main): Allow %s on entry(%s)"
 				": root user\n", 
 				o_connid, o_opid,
 				acl_access2str(access),
@@ -448,7 +448,7 @@ acl_access_allowed(
 		TNF_PROBE_0_DEBUG(acl_entry_first_touch_start,"ACL","");
 
 		slapi_log_err(loglevel, plugin_name,
-			"acl_access_allowed - #### conn=%" NSPRIu64 " op=%d binddn=\"%s\"\n",
+			"acl_access_allowed - #### conn=%" PRIu64 " op=%d binddn=\"%s\"\n",
 			o_connid, o_opid, clientDn);
 		aclpb->aclpb_stat_total_entries++;
 
@@ -776,7 +776,7 @@ print_access_control_summary( char *source, int ret_val, char *clientDn,
                                 null_user);
                         if (strcasecmp(right, access_str_moddn) == 0) {
                                  slapi_log_err(loglevel, plugin_name, "print_access_control_summary - "                                            
-                                        "conn=%" NSPRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) [from %s] to proxy (%s)"
+                                        "conn=%" PRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) [from %s] to proxy (%s)"
                                          ": %s\n",
                                         o_connid, o_opid,
                                         source,
@@ -790,7 +790,7 @@ print_access_control_summary( char *source, int ret_val, char *clientDn,
 
                         } else {
                                 slapi_log_err(loglevel, plugin_name, 
-                                        "print_access_control_summary - conn=%" NSPRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) to proxy (%s)"
+                                        "print_access_control_summary - conn=%" PRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) to proxy (%s)"
                                          ": %s\n",
                                         o_connid, o_opid,
                                         source,
@@ -805,7 +805,7 @@ print_access_control_summary( char *source, int ret_val, char *clientDn,
                         proxy_user = null_user;
                         if (strcasecmp(right, access_str_moddn) == 0) {
                                 slapi_log_err(loglevel, plugin_name, 
-                                        "print_access_control_summary - conn=%" NSPRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) [from %s] to proxy (%s)"
+                                        "print_access_control_summary - conn=%" PRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) [from %s] to proxy (%s)"
                                         ": %s\n",
                                         o_connid, o_opid,
                                         source,
@@ -819,7 +819,7 @@ print_access_control_summary( char *source, int ret_val, char *clientDn,
                                 
                         } else {
                                 slapi_log_err(loglevel, plugin_name, 
-                                        "print_access_control_summary - conn=%" NSPRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) to proxy (%s)"
+                                        "print_access_control_summary - conn=%" PRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) to proxy (%s)"
                                         ": %s\n",
                                         o_connid, o_opid,
                                         source,
@@ -834,7 +834,7 @@ print_access_control_summary( char *source, int ret_val, char *clientDn,
 	} else {
                 if (strcasecmp(right, access_str_moddn) == 0) {
                         slapi_log_err(loglevel, plugin_name, 
-                                "print_access_control_summary - conn=%" NSPRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) [from %s] to %s"
+                                "print_access_control_summary - conn=%" PRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) [from %s] to %s"
                                 ": %s\n",
                                 o_connid, o_opid,
                                 source,
@@ -848,7 +848,7 @@ print_access_control_summary( char *source, int ret_val, char *clientDn,
                         
                 } else {
                         slapi_log_err(loglevel, plugin_name, 
-                                "print_access_control_summary - conn=%" NSPRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) to %s"
+                                "print_access_control_summary - conn=%" PRIu64 " op=%d (%s): %s %s on entry(%s).attr(%s) to %s"
                                 ": %s\n",
                                 o_connid, o_opid,
                                 source,
diff --git a/ldap/servers/plugins/acl/acl.h b/ldap/servers/plugins/acl/acl.h
index 91f5071..8b3486c 100644
--- a/ldap/servers/plugins/acl/acl.h
+++ b/ldap/servers/plugins/acl/acl.h
@@ -20,22 +20,6 @@
 #ifndef _ACL_H_
 #define _ACL_H_
 
-/* Required to get portable printf/scanf format macros */
-#ifdef HAVE_INTTYPES_H
-#include <inttypes.h>
-
-/* NSPR uses the print macros a bit differently than ANSI C.  We
- * need to use ll for a 64-bit integer, even when a long is 64-bit.
- */
-#undef PRIu64
-#define PRIu64  "llu"
-#undef PRI64
-#define PRI64   "ll"
-
-#else
-#error Need to define portable format macros such as PRIu64
-#endif /* HAVE_INTTYPES_H */
-
 #include 	<stdio.h>
 #include 	<string.h>
 #include 	<sys/types.h>
diff --git a/ldap/servers/plugins/acl/aclanom.c b/ldap/servers/plugins/acl/aclanom.c
index 5462d87..96d0d9f 100644
--- a/ldap/servers/plugins/acl/aclanom.c
+++ b/ldap/servers/plugins/acl/aclanom.c
@@ -523,7 +523,7 @@ aclanom_match_profile (Slapi_PBlock *pb, struct acl_pblock *aclpb, Slapi_Entry *
 			aci_ndn = slapi_sdn_get_ndn (acl_anom_profile->anom_targetinfo[i].anom_target);
 			if (access & SLAPI_ACL_MODDN) {
 				slapi_log_err(loglevel, plugin_name, 
-					"aclanom_match_profile - conn=%" NSPRIu64 " op=%d: Allow access on entry(%s).attr(%s) (from %s) to anonymous: acidn=\"%s\"\n",
+					"aclanom_match_profile - conn=%" PRIu64 " op=%d: Allow access on entry(%s).attr(%s) (from %s) to anonymous: acidn=\"%s\"\n",
 					o_connid, o_opid,
 					ndn,
 					attr ? attr:"NULL",
@@ -532,7 +532,7 @@ aclanom_match_profile (Slapi_PBlock *pb, struct acl_pblock *aclpb, Slapi_Entry *
 				
 			} else {
 				slapi_log_err(loglevel, plugin_name, 
-					"aclanom_match_profile - conn=%" NSPRIu64 " op=%d: Allow access on entry(%s).attr(%s) to anonymous: acidn=\"%s\"\n",
+					"aclanom_match_profile - conn=%" PRIu64 " op=%d: Allow access on entry(%s).attr(%s) to anonymous: acidn=\"%s\"\n",
 					o_connid, o_opid,
 					ndn,
 					attr ? attr:"NULL",
@@ -541,13 +541,13 @@ aclanom_match_profile (Slapi_PBlock *pb, struct acl_pblock *aclpb, Slapi_Entry *
 		} else {
 			if (access & SLAPI_ACL_MODDN) {
 				slapi_log_err(loglevel, plugin_name,
-					"aclanom_match_profile - conn=%" NSPRIu64 " op=%d: Deny access on entry(%s).attr(%s) (from %s) to anonymous\n",
+					"aclanom_match_profile - conn=%" PRIu64 " op=%d: Deny access on entry(%s).attr(%s) (from %s) to anonymous\n",
 					o_connid, o_opid,
 					ndn, attr ? attr:"NULL" ,
 					aclpb->aclpb_moddn_source_sdn ? slapi_sdn_get_dn(aclpb->aclpb_moddn_source_sdn) : "NULL");
 			} else {
 				slapi_log_err(loglevel, plugin_name,
-					"aclanom_match_profile - conn=%" NSPRIu64 " op=%d: Deny access on entry(%s).attr(%s) to anonymous\n",
+					"aclanom_match_profile - conn=%" PRIu64 " op=%d: Deny access on entry(%s).attr(%s) to anonymous\n",
 					o_connid, o_opid,
 					ndn, attr ? attr:"NULL" );
 			}
diff --git a/ldap/servers/plugins/dna/dna.c b/ldap/servers/plugins/dna/dna.c
index 34011b9..a085941 100644
--- a/ldap/servers/plugins/dna/dna.c
+++ b/ldap/servers/plugins/dna/dna.c
@@ -23,14 +23,6 @@
 #include "slapi-private.h"
 #include "prclist.h"
 
-/* Required to get portable printf/scanf format macros */
-#ifdef HAVE_INTTYPES_H
-#include <inttypes.h>
-
-#else
-#error Need to define portable format macros such as PRIu64
-#endif /* HAVE_INTTYPES_H */
-
 #include <sys/stat.h>
 
 #define DNA_PLUGIN_SUBSYSTEM "dna-plugin"
@@ -997,7 +989,7 @@ dna_parse_config_entry(Slapi_PBlock *pb, Slapi_Entry * e, int apply)
     }
 
     slapi_log_err(SLAPI_LOG_CONFIG, DNA_PLUGIN_SUBSYSTEM,
-                    "dna_parse_config_entry - %s [%" NSPRIu64 "]\n", DNA_NEXTVAL,
+                    "dna_parse_config_entry - %s [%" PRIu64 "]\n", DNA_NEXTVAL,
                     entry->nextval);
 
     value = slapi_entry_attr_get_charptr(e, DNA_PREFIX);
@@ -1026,7 +1018,7 @@ dna_parse_config_entry(Slapi_PBlock *pb, Slapi_Entry * e, int apply)
     }
 
     slapi_log_err(SLAPI_LOG_CONFIG, DNA_PLUGIN_SUBSYSTEM,
-                    "dna_parse_config_entry - %s [%" NSPRIu64 "]\n", DNA_INTERVAL, entry->interval);
+                    "dna_parse_config_entry - %s [%" PRIu64 "]\n", DNA_INTERVAL, entry->interval);
 #endif
 
     value = slapi_entry_attr_get_charptr(e, DNA_GENERATE);
@@ -1126,7 +1118,7 @@ dna_parse_config_entry(Slapi_PBlock *pb, Slapi_Entry * e, int apply)
     }
 
     slapi_log_err(SLAPI_LOG_CONFIG, DNA_PLUGIN_SUBSYSTEM,
-                    "dna_parse_config_entry - %s [%" NSPRIu64 "]\n", DNA_MAXVAL,
+                    "dna_parse_config_entry - %s [%" PRIu64 "]\n", DNA_MAXVAL,
                     entry->maxval);
 
     /* get the global bind dn and password(if any) */
@@ -1256,7 +1248,7 @@ dna_parse_config_entry(Slapi_PBlock *pb, Slapi_Entry * e, int apply)
     }
 
     slapi_log_err(SLAPI_LOG_CONFIG, DNA_PLUGIN_SUBSYSTEM,
-                    "dna_parse_config_entry - %s [%" NSPRIu64 "]\n", DNA_THRESHOLD,
+                    "dna_parse_config_entry - %s [%" PRIu64 "]\n", DNA_THRESHOLD,
                     entry->threshold);
 
     value = slapi_entry_attr_get_charptr(e, DNA_RANGE_REQUEST_TIMEOUT);
@@ -1268,7 +1260,7 @@ dna_parse_config_entry(Slapi_PBlock *pb, Slapi_Entry * e, int apply)
     }
 
     slapi_log_err(SLAPI_LOG_CONFIG, DNA_PLUGIN_SUBSYSTEM,
-                    "dna_parse_config_entry - %s [%" NSPRIu64 "]\n", DNA_RANGE_REQUEST_TIMEOUT,
+                    "dna_parse_config_entry - %s [%" PRIu64 "]\n", DNA_RANGE_REQUEST_TIMEOUT,
                     entry->timeout);
 
     value = slapi_entry_attr_get_charptr(e, DNA_NEXT_RANGE);
@@ -2307,7 +2299,7 @@ dna_first_free_value(struct configEntry *config_entry,
             return LDAP_OPERATIONS_ERROR;
         }
 
-        filter = slapi_ch_smprintf("(&%s(&(%s>=%" NSPRIu64 ")(%s<=%" NSPRIu64 ")))",
+        filter = slapi_ch_smprintf("(&%s(&(%s>=%" PRIu64 ")(%s<=%" PRIu64 ")))",
                                    config_entry->filter,
                                    config_entry->types[0], tmpval,
                                    config_entry->types[0], config_entry->maxval);
@@ -2497,7 +2489,7 @@ static int dna_get_next_value(struct configEntry *config_entry,
     if ((config_entry->maxval == -1) ||
         (nextval <= (config_entry->maxval + config_entry->interval))) {
         /* try to set the new next value in the config entry */
-        snprintf(next_value, sizeof(next_value),"%" NSPRIu64, nextval);
+        snprintf(next_value, sizeof(next_value),"%" PRIu64, nextval);
 
         /* set up our replace modify operation */
         replace_val[0] = next_value;
@@ -2524,7 +2516,7 @@ static int dna_get_next_value(struct configEntry *config_entry,
 
     if (LDAP_SUCCESS == ret) {
         slapi_ch_free_string(next_value_ret);
-        *next_value_ret = slapi_ch_smprintf("%" NSPRIu64, setval);
+        *next_value_ret = slapi_ch_smprintf("%" PRIu64, setval);
         if (NULL == *next_value_ret) {
             ret = LDAP_OPERATIONS_ERROR;
             goto done;
@@ -2609,7 +2601,7 @@ dna_update_shared_config(struct configEntry *config_entry)
 
         /* We store the number of remaining assigned values
          * in the shared config entry. */
-        snprintf(remaining_vals, sizeof(remaining_vals),"%" NSPRIu64,
+        snprintf(remaining_vals, sizeof(remaining_vals),"%" PRIu64,
                 config_entry->remaining);
 
         /* set up our replace modify operation */
@@ -2709,7 +2701,7 @@ dna_update_next_range(struct configEntry *config_entry,
     int ret = 0;
 
     /* Try to set the new next range in the config entry. */
-    snprintf(nextrange_value, sizeof(nextrange_value), "%" NSPRIu64 "-%" NSPRIu64,
+    snprintf(nextrange_value, sizeof(nextrange_value), "%" PRIu64 "-%" PRIu64,
     		lower, upper);
 
     /* set up our replace modify operation */
@@ -2778,8 +2770,8 @@ dna_activate_next_range(struct configEntry *config_entry)
     int ret = 0;
 
     /* Setup the modify operation for the config entry */
-    snprintf(maxval_val, sizeof(maxval_val),"%" NSPRIu64, config_entry->next_range_upper);
-    snprintf(nextval_val, sizeof(nextval_val),"%" NSPRIu64, config_entry->next_range_lower);
+    snprintf(maxval_val, sizeof(maxval_val),"%" PRIu64, config_entry->next_range_upper);
+    snprintf(nextval_val, sizeof(nextval_val),"%" PRIu64, config_entry->next_range_lower);
 
     maxval_vals[0] = maxval_val;
     maxval_vals[1] = 0;
@@ -3319,7 +3311,7 @@ dna_create_valcheck_filter(struct configEntry *config_entry, PRUint64 value, cha
      * - the string length of the filter in the config
      * - the string length sum of all configured types
      * - 23 bytes for each type (20 for the max string
-     *   representation of a NSPRIu64, 3 for "(=)"
+     *   representation of a PRIu64, 3 for "(=)"
      * - 3 bytes for the beginning and end of the filter - "(&" and ")"
      * - 3 bytes to OR together multiple types (if present) - "(|" and ")"
      * - the string length of the prefix (if one is configured) for each type
@@ -3556,8 +3548,8 @@ _dna_pre_op_add(Slapi_PBlock *pb, Slapi_Entry *e, char **errstr)
                     (config_entry->remaining <= config_entry->threshold)) {
                     slapi_log_err(SLAPI_LOG_PLUGIN, DNA_PLUGIN_SUBSYSTEM,
                                     "_dna_pre_op_add - Passed threshold of %" 
-                                    NSPRIu64 " remaining values "
-                                    "for range %s. (%" NSPRIu64 " values remain)\n",
+                                    PRIu64 " remaining values "
+                                    "for range %s. (%" PRIu64 " values remain)\n",
                                     config_entry->threshold, config_entry->dn,
                                     config_entry->remaining);
                     dna_fix_maxval(config_entry, 0);
@@ -3828,8 +3820,8 @@ _dna_pre_op_modify(Slapi_PBlock *pb, Slapi_Entry *e, Slapi_Mods *smods, char **e
                     (config_entry->remaining <= config_entry->threshold)) {
                     slapi_log_err(SLAPI_LOG_ERR, DNA_PLUGIN_SUBSYSTEM,
                                     "_dna_pre_op_modify - Passed threshold of %" 
-                                    NSPRIu64 " remaining values "
-                                    "for range %s. (%" NSPRIu64 " values remain)\n",
+                                    PRIu64 " remaining values "
+                                    "for range %s. (%" PRIu64 " values remain)\n",
                                     config_entry->threshold, config_entry->dn,
                                     config_entry->remaining);
                     dna_fix_maxval(config_entry, 0);
@@ -4411,8 +4403,8 @@ static int dna_extend_exop(Slapi_PBlock *pb)
         char highstr[16];
 
         /* Create the exop response */
-        snprintf(lowstr, sizeof(lowstr), "%" NSPRIu64, lower);
-        snprintf(highstr, sizeof(highstr), "%" NSPRIu64, upper);
+        snprintf(lowstr, sizeof(lowstr), "%" PRIu64, lower);
+        snprintf(highstr, sizeof(highstr), "%" PRIu64, upper);
         range_low.bv_val = lowstr;
         range_low.bv_len = strlen(range_low.bv_val);
         range_high.bv_val = highstr;
@@ -4445,7 +4437,7 @@ static int dna_extend_exop(Slapi_PBlock *pb)
         ber_bvfree(respdata);
 
         slapi_log_err(SLAPI_LOG_PLUGIN, DNA_PLUGIN_SUBSYSTEM,
-                        "dna_extend_exop - Released range %" NSPRIu64 "-%" NSPRIu64 ".\n",
+                        "dna_extend_exop - Released range %" PRIu64 "-%" PRIu64 ".\n",
                         lower, upper);
     }
 
@@ -4588,7 +4580,7 @@ dna_release_range(char *range_dn, PRUint64 *lower, PRUint64 *upper)
                 *lower = *upper - release + 1;
 
                 /* try to set the new maxval in the config entry */
-                snprintf(max_value, sizeof(max_value),"%" NSPRIu64, (*lower - 1));
+                snprintf(max_value, sizeof(max_value),"%" PRIu64, (*lower - 1));
 
                 /* set up our replace modify operation */
                 replace_val[0] = max_value;
diff --git a/ldap/servers/plugins/posix-winsync/posix-winsync.c b/ldap/servers/plugins/posix-winsync/posix-winsync.c
index 63444e5..21e4ad0 100644
--- a/ldap/servers/plugins/posix-winsync/posix-winsync.c
+++ b/ldap/servers/plugins/posix-winsync/posix-winsync.c
@@ -270,7 +270,7 @@ sync_acct_disable(void *cbdata, /* the usual domain config data */
         if (update_entry) {
             slapi_entry_attr_set_ulong(update_entry, "userAccountControl", adval);
             slapi_log_err(SLAPI_LOG_PLUGIN, posix_winsync_plugin_name,
-                "<-- sync_acct_disable - %s AD account [%s] - new value is [%" NSPRIu64 "]\n",
+                "<-- sync_acct_disable - %s AD account [%s] - new value is [%" PRIu64 "]\n",
 				(ds_is_enabled) ? "enabled" : "disabled", slapi_entry_get_dn_const(update_entry), adval);
         } else {
             /* iterate through the mods - if there is already a mod
@@ -326,7 +326,7 @@ sync_acct_disable(void *cbdata, /* the usual domain config data */
                 mod_bval->bv_len = strlen(acctvalstr);
             }
             slapi_log_err(SLAPI_LOG_PLUGIN, posix_winsync_plugin_name,
-                "<-- sync_acct_disable - %s AD account [%s] - new value is [%" NSPRIu64 "]\n",
+                "<-- sync_acct_disable - %s AD account [%s] - new value is [%" PRIu64 "]\n",
 				(ds_is_enabled) ? "enabled" : "disabled", slapi_entry_get_dn_const(ad_entry), adval);
         }
     }
diff --git a/ldap/servers/plugins/replication/repl.h b/ldap/servers/plugins/replication/repl.h
index 89ad481..9460ca9 100644
--- a/ldap/servers/plugins/replication/repl.h
+++ b/ldap/servers/plugins/replication/repl.h
@@ -15,21 +15,8 @@
 #ifndef _REPL_H_
 #define _REPL_H_
 
-/* Required to get portable printf/scanf format macros */
-#ifdef HAVE_INTTYPES_H
-#include <inttypes.h>
-
-/* NSPR uses the print macros a bit differently than ANSI C.  We
- * need to use ll for a 64-bit integer, even when a long is 64-bit.
- */
-#undef PRIu64
-#define PRIu64  "llu"
-#undef PRI64
-#define PRI64   "ll"
-
-#else
-#error Need to define portable format macros such as PRIu64
-#endif /* HAVE_INTTYPES_H */
+/* Provides our int types and platform specific requirements. */
+#include <slapi_pal.h>
 
 #include <limits.h>
 #include <time.h>
diff --git a/ldap/servers/plugins/replication/repl5_inc_protocol.c b/ldap/servers/plugins/replication/repl5_inc_protocol.c
index a5ae885..36c279e 100644
--- a/ldap/servers/plugins/replication/repl5_inc_protocol.c
+++ b/ldap/servers/plugins/replication/repl5_inc_protocol.c
@@ -2104,7 +2104,7 @@ repl5_inc_stop(Private_Repl_Protocol *prp)
 		/* Isn't listening. Do something drastic. */
 		return_value = -1;
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
-				"repl5_inc_stop - %s: Protocol does not stop after %" NSPRIu64 " seconds\n",
+				"repl5_inc_stop - %s: Protocol does not stop after %" PRIu64 " seconds\n",
 				agmt_get_long_name(prp->agmt), timeout);
 	}
 	else
diff --git a/ldap/servers/plugins/replication/repl5_init.c b/ldap/servers/plugins/replication/repl5_init.c
index 9549dcf..edffb84 100644
--- a/ldap/servers/plugins/replication/repl5_init.c
+++ b/ldap/servers/plugins/replication/repl5_init.c
@@ -208,7 +208,7 @@ get_repl_session_id (Slapi_PBlock *pb, char *idstr, CSN **csn)
 		/* Avoid "Connection is NULL and hence cannot access SLAPI_CONN_ID" */
 		if (opid) {
 			slapi_pblock_get (pb, SLAPI_CONN_ID, &connid);
-			snprintf (idstr, REPL_SESSION_ID_SIZE, "conn=%" NSPRIu64 " op=%d",
+			snprintf (idstr, REPL_SESSION_ID_SIZE, "conn=%" PRIu64 " op=%d",
 					connid, opid);
 		}
 
diff --git a/ldap/servers/plugins/replication/repl5_plugins.c b/ldap/servers/plugins/replication/repl5_plugins.c
index 357c093..ebcc230 100644
--- a/ldap/servers/plugins/replication/repl5_plugins.c
+++ b/ldap/servers/plugins/replication/repl5_plugins.c
@@ -1335,7 +1335,7 @@ process_postop (Slapi_PBlock *pb)
 			{
 				slapi_log_err(SLAPI_LOG_ERR, repl_plugin_name,
 					"process_postop - Failed to apply update (%s) error (%d).  "
-					"Aborting replication session(conn=%" NSPRIu64 " op=%d)\n",
+					"Aborting replication session(conn=%" PRIu64 " op=%d)\n",
 					csn_as_string(opcsn, PR_FALSE, csn_str), retval,
 					connid, opid);
 				/*
diff --git a/ldap/servers/plugins/replication/repl5_replica.c b/ldap/servers/plugins/replication/repl5_replica.c
index 5718a98..a106f8b 100644
--- a/ldap/servers/plugins/replication/repl5_replica.c
+++ b/ldap/servers/plugins/replication/repl5_replica.c
@@ -596,7 +596,7 @@ replica_get_exclusive_access(Replica *r, PRBool *isInc, PRUint64 connid, int opi
 
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"replica_get_exclusive_access - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+				"conn=%" PRIu64 " op=%d repl=\"%s\": "
 				"Replica in use locking_purl=%s\n",
 				connid, opid,
 				slapi_sdn_get_dn(r->repl_root),
@@ -620,7 +620,7 @@ replica_get_exclusive_access(Replica *r, PRBool *isInc, PRUint64 connid, int opi
 	{
         slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
         		"replica_get_exclusive_access - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": Acquired replica\n",
+				"conn=%" PRIu64 " op=%d repl=\"%s\": Acquired replica\n",
 				connid, opid,
 				slapi_sdn_get_dn(r->repl_root));
 		r->repl_state_flags |= REPLICA_IN_USE;
@@ -664,13 +664,13 @@ replica_relinquish_exclusive_access(Replica *r, PRUint64 connid, int opid)
 	{
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"replica_relinquish_exclusive_access - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+				"conn=%" PRIu64 " op=%d repl=\"%s\": "
 				"Replica not in use\n",
 				connid, opid, slapi_sdn_get_dn(r->repl_root));
 	} else {
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"replica_relinquish_exclusive_access - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+				"conn=%" PRIu64 " op=%d repl=\"%s\": "
 				"Released replica held by locking_purl=%s\n",
 				connid, opid,
 				slapi_sdn_get_dn(r->repl_root),	r->locking_purl);
diff --git a/ldap/servers/plugins/replication/repl5_total.c b/ldap/servers/plugins/replication/repl5_total.c
index af570a8..064a099 100644
--- a/ldap/servers/plugins/replication/repl5_total.c
+++ b/ldap/servers/plugins/replication/repl5_total.c
@@ -853,7 +853,7 @@ multimaster_extop_NSDS50ReplicationEntry(Slapi_PBlock  *pb)
            const char *dn = slapi_entry_get_dn_const(e);
            slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
                    "multimaster_extop_NSDS50ReplicationEntry - "
-                   "Error %d: could not import entry dn %s for total update operation conn=%" NSPRIu64 " op=%d\n",
+                   "Error %d: could not import entry dn %s for total update operation conn=%" PRIu64 " op=%d\n",
                    rc, dn, connid, opid);
 		   rc = -1;
 	   }
@@ -864,7 +864,7 @@ multimaster_extop_NSDS50ReplicationEntry(Slapi_PBlock  *pb)
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"multimaster_extop_NSDS50ReplicationEntry - "
 				"Error %d: could not decode the total update extop "
-				"for total update operation conn=%" NSPRIu64 " op=%d\n",
+				"for total update operation conn=%" PRIu64 " op=%d\n",
 				rc, connid, opid);
 	}
    
diff --git a/ldap/servers/plugins/replication/repl_connext.c b/ldap/servers/plugins/replication/repl_connext.c
index 29dc2a7..ba0fa15 100644
--- a/ldap/servers/plugins/replication/repl_connext.c
+++ b/ldap/servers/plugins/replication/repl_connext.c
@@ -84,7 +84,7 @@ void consumer_connection_extension_destructor (void *ext, void *object, void *pa
 					slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 							"consumer_connection_extension_destructor - "
 							"Aborting total update in progress for replicated "
-							"area %s connid=%" NSPRIu64 "\n", slapi_sdn_get_dn(repl_root_sdn), connid);
+							"area %s connid=%" PRIu64 "\n", slapi_sdn_get_dn(repl_root_sdn), connid);
 					slapi_stop_bulk_import(pb);
 				}
 				else
@@ -156,7 +156,7 @@ consumer_connection_extension_acquire_exclusive_access(void* conn, PRUint64 conn
             ret = connext;
             slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
             		"consumer_connection_extension_acquire_exclusive_access - "
-                    "conn=%" NSPRIu64 " op=%d Acquired consumer connection extension\n",
+                    "conn=%" PRIu64 " op=%d Acquired consumer connection extension\n",
                     connid, opid);
         }
         else if (opid == connext->in_use_opid)
@@ -164,14 +164,14 @@ consumer_connection_extension_acquire_exclusive_access(void* conn, PRUint64 conn
             ret = connext;
             slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
             		"consumer_connection_extension_acquire_exclusive_access - "
-                    "conn=%" NSPRIu64 " op=%d Reacquired consumer connection extension\n",
+                    "conn=%" PRIu64 " op=%d Reacquired consumer connection extension\n",
                     connid, opid);
         }
         else
         {
             slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
             		"consumer_connection_extension_acquire_exclusive_access - "
-                    "conn=%" NSPRIu64 " op=%d Could not acquire consumer connection extension; it is in use by op=%d\n",
+                    "conn=%" PRIu64 " op=%d Could not acquire consumer connection extension; it is in use by op=%d\n",
                     connid, opid, connext->in_use_opid);
         }
 
@@ -182,7 +182,7 @@ consumer_connection_extension_acquire_exclusive_access(void* conn, PRUint64 conn
     {
         slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
         		"consumer_connection_extension_acquire_exclusive_access - "
-                "conn=%" NSPRIu64 " op=%d Could not acquire consumer extension, it is NULL!\n",
+                "conn=%" PRIu64 " op=%d Could not acquire consumer extension, it is NULL!\n",
                 connid, opid);
     }
     
@@ -221,7 +221,7 @@ consumer_connection_extension_relinquish_exclusive_access(void* conn, PRUint64 c
         {
             slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
             		"consumer_connection_extension_relinquish_exclusive_access - "
-                    "conn=%" NSPRIu64 " op=%d Consumer connection extension is not in use\n",
+                    "conn=%" PRIu64 " op=%d Consumer connection extension is not in use\n",
                     connid, opid);
             ret = 2;
         }
@@ -230,7 +230,7 @@ consumer_connection_extension_relinquish_exclusive_access(void* conn, PRUint64 c
             /* step 4, relinquish it (normal) */
             slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
             		"consumer_connection_extension_relinquish_exclusive_access - "
-                    "conn=%" NSPRIu64 " op=%d Relinquishing consumer connection extension\n",
+                    "conn=%" PRIu64 " op=%d Relinquishing consumer connection extension\n",
                     connid, opid);
             connext->in_use_opid = -1;
             ret = 1;
@@ -240,7 +240,7 @@ consumer_connection_extension_relinquish_exclusive_access(void* conn, PRUint64 c
             /* step 4, relinquish it (forced) */
             slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
             		"consumer_connection_extension_relinquish_exclusive_access - "
-                    "conn=%" NSPRIu64 " op=%d Forced to relinquish consumer connection extension held by op=%d\n",
+                    "conn=%" PRIu64 " op=%d Forced to relinquish consumer connection extension held by op=%d\n",
                     connid, opid, connext->in_use_opid);
             connext->in_use_opid = -1;
             ret = 1;
@@ -249,7 +249,7 @@ consumer_connection_extension_relinquish_exclusive_access(void* conn, PRUint64 c
         {
             slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
             		"consumer_connection_extension_relinquish_exclusive_access - "
-                    "conn=%" NSPRIu64 " op=%d Not relinquishing consumer connection extension, it is held by op=%d!\n",
+                    "conn=%" PRIu64 " op=%d Not relinquishing consumer connection extension, it is held by op=%d!\n",
                     connid, opid, connext->in_use_opid);
         }
         
@@ -260,7 +260,7 @@ consumer_connection_extension_relinquish_exclusive_access(void* conn, PRUint64 c
     {
         slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
         		"consumer_connection_extension_relinquish_exclusive_access - "
-                "conn=%" NSPRIu64 " op=%d Could not relinquish consumer extension, it is NULL!\n",
+                "conn=%" PRIu64 " op=%d Could not relinquish consumer extension, it is NULL!\n",
                 connid, opid);
     }
     
diff --git a/ldap/servers/plugins/replication/repl_extop.c b/ldap/servers/plugins/replication/repl_extop.c
index 80580f9..412caec 100644
--- a/ldap/servers/plugins/replication/repl_extop.c
+++ b/ldap/servers/plugins/replication/repl_extop.c
@@ -668,7 +668,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 		connext->repl_protocol_version = REPL_PROTOCOL_50_INCREMENTAL;
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 			"multimaster_extop_StartNSDS50ReplicationRequest - "
-			"conn=%" NSPRIu64 " op=%d repl=\"%s\": Begin incremental protocol\n",
+			"conn=%" PRIu64 " op=%d repl=\"%s\": Begin incremental protocol\n",
 			connid, opid, repl_root);
 		isInc = PR_TRUE;
 	}
@@ -695,7 +695,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 		}
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"multimaster_extop_StartNSDS50ReplicationRequest - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": Begin total protocol\n",
+				"conn=%" PRIu64 " op=%d repl=\"%s\": Begin total protocol\n",
 				connid, opid, repl_root);
 		isInc = PR_FALSE;
 	}
@@ -705,7 +705,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 		connext->repl_protocol_version = REPL_PROTOCOL_50_INCREMENTAL;
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 			"multimaster_extop_StartNSDS50ReplicationRequest - "
-			"conn=%" NSPRIu64 " op=%d repl=\"%s\": Begin 7.1 incremental protocol\n",
+			"conn=%" PRIu64 " op=%d repl=\"%s\": Begin 7.1 incremental protocol\n",
 			connid, opid, repl_root);
 		isInc = PR_TRUE;
 	}
@@ -718,7 +718,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 		}
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"multimaster_extop_StartNSDS50ReplicationRequest - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": Begin 7.1 total protocol\n",
+				"conn=%" PRIu64 " op=%d repl=\"%s\": Begin 7.1 total protocol\n",
 				connid, opid, repl_root);
 		isInc = PR_FALSE;
 	}
@@ -741,7 +741,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 	{
         slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
         		"multimaster_extop_StartNSDS50ReplicationRequest - "
-				"conn=%" NSPRIu64 " op=%d replica=\"%s\": "
+				"conn=%" PRIu64 " op=%d replica=\"%s\": "
 				"Replica is being configured: try again later\n",
 				connid, opid, repl_root);
 		response = NSDS50_REPL_REPLICA_BUSY;
@@ -814,7 +814,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 				{
 					slapi_log_err(SLAPI_LOG_ERR, repl_plugin_name,
 							"multimaster_extop_StartNSDS50ReplicationRequest - "
-							"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+							"conn=%" PRIu64 " op=%d repl=\"%s\": "
 							"Excessive clock skew from supplier RUV\n",
 							connid, opid, repl_root);
 					response = NSDS50_REPL_EXCESSIVE_CLOCK_SKEW;
@@ -852,7 +852,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 	if (check_replica_id_uniqueness(replica, supplier_ruv) != 0){
         slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
         		"multimaster_extop_StartNSDS50ReplicationRequest - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+				"conn=%" PRIu64 " op=%d repl=\"%s\": "
 				"Replica has same replicaID %d as supplier\n",
 				connid, opid, repl_root, replica_get_rid(replica));
 		response = NSDS50_REPL_REPLICAID_ERROR;
@@ -865,7 +865,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 	 * the session's conn id and op id to identify the the supplier.
 	 */
 	/* junkrc = ruv_get_first_id_and_purl(supplier_ruv, &junkrid, &locking_purl); */
-	snprintf(locking_session, sizeof(locking_session), "conn=%" NSPRIu64 " id=%d",
+	snprintf(locking_session, sizeof(locking_session), "conn=%" PRIu64 " id=%d",
 			connid, opid);
 	locking_purl = &locking_session[0];
 	if (replica_get_exclusive_access(replica, &isInc, connid, opid,
@@ -892,7 +892,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 		int max = 480 * 5;
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"multimaster_extop_StartNSDS50ReplicationRequest - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+				"conn=%" PRIu64 " op=%d repl=\"%s\": "
 				"374 - Starting sleep: connext->repl_protocol_version == %d\n",
 				connid, opid, repl_root, connext->repl_protocol_version);
         
@@ -902,7 +902,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
         
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"multimaster_extop_StartNSDS50ReplicationRequest - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+				"conn=%" PRIu64 " op=%d repl=\"%s\": "
 				"374 - Finished sleep: connext->repl_protocol_version == %d\n",
 				connid, opid, repl_root, connext->repl_protocol_version);
 	}
@@ -997,7 +997,7 @@ multimaster_extop_StartNSDS50ReplicationRequest(Slapi_PBlock *pb)
 		response = NSDS50_REPL_INTERNAL_ERROR;
 		slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 				"multimaster_extop_StartNSDS50ReplicationRequest - "
-				"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+				"conn=%" PRIu64 " op=%d repl=\"%s\": "
 				"Unexpected update protocol received: %d.  "
 				"Expected incremental or total.\n",
 				connid, opid, repl_root, connext->repl_protocol_version);
@@ -1039,7 +1039,7 @@ send_response:
 		slapi_log_err (resp_log_level,
 			repl_plugin_name,
 			"multimaster_extop_StartNSDS50ReplicationRequest - "
-			"conn=%" NSPRIu64 " op=%d replica=\"%s\": "
+			"conn=%" PRIu64 " op=%d replica=\"%s\": "
 			"Unable to acquire replica: error: %s%s\n",
 			connid, opid,
 			(replica ? slapi_sdn_get_dn(replica_get_root(replica)) : "unknown"),
@@ -1092,7 +1092,7 @@ send_response:
 	slapi_pblock_set(pb, SLAPI_EXT_OP_RET_VALUE, resp_bval);
 	slapi_log_err(SLAPI_LOG_REPL, repl_plugin_name,
 			"multimaster_extop_StartNSDS50ReplicationRequest - "
-			"conn=%" NSPRIu64 " op=%d repl=\"%s\": "
+			"conn=%" PRIu64 " op=%d repl=\"%s\": "
 			"%s: response=%d rc=%d\n",
 			connid, opid, repl_root,
 			is90 ? "StartNSDS90ReplicationRequest" :
diff --git a/ldap/servers/plugins/sync/sync_persist.c b/ldap/servers/plugins/sync/sync_persist.c
index 667a529..bd856cb 100644
--- a/ldap/servers/plugins/sync/sync_persist.c
+++ b/ldap/servers/plugins/sync/sync_persist.c
@@ -548,14 +548,14 @@ sync_send_results( void *arg )
 	slapi_pblock_get(req->req_pblock, SLAPI_CONNECTION, &conn);
 	if (NULL == conn) {
 		slapi_log_err(SLAPI_LOG_ERR, SYNC_PLUGIN_SUBSYSTEM,
-			"sync_send_results - conn=%" NSPRIu64 " op=%d Null connection - aborted\n",
+			"sync_send_results - conn=%" PRIu64 " op=%d Null connection - aborted\n",
 			connid, opid);
 		goto done;
 	}
 	conn_acq_flag = sync_acquire_connection (conn);
 	if (conn_acq_flag) {
 		slapi_log_err(SLAPI_LOG_ERR, SYNC_PLUGIN_SUBSYSTEM,
-			"sync_send_results - conn=%" NSPRIu64 " op=%d Could not acquire the connection - aborted\n",
+			"sync_send_results - conn=%" PRIu64 " op=%d Could not acquire the connection - aborted\n",
 			connid, opid);
 		goto done;
 	}
@@ -566,7 +566,7 @@ sync_send_results( void *arg )
 		/* Check for an abandoned operation */
 		if ( op == NULL || slapi_is_operation_abandoned( op ) ) {
 			slapi_log_err(SLAPI_LOG_PLUGIN, SYNC_PLUGIN_SUBSYSTEM,
-						"sync_send_results - conn=%" NSPRIu64 " op=%d Operation no longer active - terminating\n",
+						"sync_send_results - conn=%" PRIu64 " op=%d Operation no longer active - terminating\n",
 						connid, opid);
 			break;
 		}
diff --git a/ldap/servers/plugins/syntaxes/validate_task.c b/ldap/servers/plugins/syntaxes/validate_task.c
index eae2d2a..c051573 100644
--- a/ldap/servers/plugins/syntaxes/validate_task.c
+++ b/ldap/servers/plugins/syntaxes/validate_task.c
@@ -201,12 +201,12 @@ syntax_validate_task_thread(void *arg)
 	slapi_pblock_destroy(search_pb);
 
 	/* Log finished message. */
-	slapi_task_log_notice(task, "Syntax validate task complete.  Found %" NSPRIu64
+	slapi_task_log_notice(task, "Syntax validate task complete.  Found %" PRIu64
 	                " invalid entries.\n", slapi_counter_get_value(td->invalid_entries));
-	slapi_task_log_status(task, "Syntax validate task complete.  Found %" NSPRIu64
+	slapi_task_log_status(task, "Syntax validate task complete.  Found %" PRIu64
 	                " invalid entries.\n", slapi_counter_get_value(td->invalid_entries));
 	slapi_log_err(SLAPI_LOG_ERR, SYNTAX_PLUGIN_SUBSYSTEM, "syntax_validate_task_thread - Complete."
-	                "  Found %" NSPRIu64 " invalid entries.\n",
+	                "  Found %" PRIu64 " invalid entries.\n",
 	                slapi_counter_get_value(td->invalid_entries));
 	slapi_task_inc_progress(task);
 
diff --git a/ldap/servers/plugins/usn/usn.c b/ldap/servers/plugins/usn/usn.c
index 5e67e0a..54ebc31 100644
--- a/ldap/servers/plugins/usn/usn.c
+++ b/ldap/servers/plugins/usn/usn.c
@@ -320,7 +320,7 @@ _usn_add_next_usn(Slapi_Entry *e, Slapi_Backend *be)
                     "--> _usn_add_next_usn\n");
 
     /* add next USN to the entry; "be" contains the usn counter */
-    usn_berval.bv_val = slapi_ch_smprintf("%" NSPRIu64, 
+    usn_berval.bv_val = slapi_ch_smprintf("%" PRIu64, 
                                           slapi_counter_get_value(be->be_usn_counter));
     usn_berval.bv_len = strlen(usn_berval.bv_val);
     slapi_entry_attr_find(e, SLAPI_ATTR_ENTRYUSN, &attr);
@@ -360,7 +360,7 @@ _usn_mod_next_usn(LDAPMod ***mods, Slapi_Backend *be)
 
     /* add next USN to the mods; "be" contains the usn counter */
     usn_berval.bv_val = counter_buf;
-    snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "%" NSPRIu64,
+    snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "%" PRIu64,
                 slapi_counter_get_value(be->be_usn_counter));
     usn_berval.bv_len = strlen(usn_berval.bv_val);
     bvals[0] = &usn_berval;
@@ -681,7 +681,7 @@ usn_rootdse_search(Slapi_PBlock *pb, Slapi_Entry* e, Slapi_Entry* entryAfter,
             /* get a next USN counter from be_usn_counter; 
              * then minus 1 from it (except if be_usn_counter has value 0) */
             if (slapi_counter_get_value(be->be_usn_counter)) {
-                snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "%" NSPRIu64,
+                snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "%" PRIu64,
                             slapi_counter_get_value(be->be_usn_counter)-1);
             } else {
                 snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "-1");
@@ -704,7 +704,7 @@ usn_rootdse_search(Slapi_PBlock *pb, Slapi_Entry* e, Slapi_Entry* entryAfter,
             /* get a next USN counter from be_usn_counter; 
              * then minus 1 from it (except if be_usn_counter has value 0) */
             if (slapi_counter_get_value(be->be_usn_counter)) {
-                snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "%" NSPRIu64,
+                snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "%" PRIu64,
                             slapi_counter_get_value(be->be_usn_counter)-1);
             } else {
                 snprintf(usn_berval.bv_val, USN_COUNTER_BUF_LEN, "-1");
diff --git a/ldap/servers/slapd/abandon.c b/ldap/servers/slapd/abandon.c
index 18ff8ce..0485006 100644
--- a/ldap/servers/slapd/abandon.c
+++ b/ldap/servers/slapd/abandon.c
@@ -119,19 +119,19 @@ do_abandon( Slapi_PBlock *pb )
 	}
 
 	if ( 0 == pagedresults_free_one_msgid_nolock(pb->pb_conn, id) ) {
-		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 
+		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 
 		    " op=%d ABANDON targetop=Simple Paged Results msgid=%d\n",
 		    pb->pb_conn->c_connid, pb->pb_op->o_opid, id );
 	} else if ( NULL == o ) {
-		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d ABANDON"
+		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d ABANDON"
 			" targetop=NOTFOUND msgid=%d\n",
 			pb->pb_conn->c_connid, pb->pb_op->o_opid, id );
 	} else if ( suppressed_by_plugin ) {
-		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d ABANDON"
+		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d ABANDON"
 			" targetop=SUPPRESSED-BY-PLUGIN msgid=%d\n",
 			pb->pb_conn->c_connid, pb->pb_op->o_opid, id );
 	} else {
-		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d ABANDON"
+		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d ABANDON"
 			" targetop=%d msgid=%d nentries=%d etime=%ld\n",
 			pb->pb_conn->c_connid, pb->pb_op->o_opid, o->o_opid, id,
 			o->o_results.r.r_search.nentries, current_time() - o->o_time );
diff --git a/ldap/servers/slapd/add.c b/ldap/servers/slapd/add.c
index 1b994a0..9c4001e 100644
--- a/ldap/servers/slapd/add.c
+++ b/ldap/servers/slapd/add.c
@@ -168,7 +168,7 @@ do_add( Slapi_PBlock *pb )
 			if (( rc = slapi_entry_add_values( e, normtype, vals ))
 				!= LDAP_SUCCESS ) {
 				slapi_log_access( LDAP_DEBUG_STATS, 
-					"conn=%" NSPRIu64 " op=%d ADD dn=\"%s\", add values for type %s failed\n",
+					"conn=%" PRIu64 " op=%d ADD dn=\"%s\", add values for type %s failed\n",
 					pb->pb_conn->c_connid, operation->o_opid,
 					slapi_entry_get_dn_const(e), normtype );
 				send_ldap_result( pb, rc, NULL, NULL, 0, NULL );
@@ -460,7 +460,7 @@ static void op_shared_add (Slapi_PBlock *pb)
 
 		if ( !internal_op )
 		{
-			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d ADD dn=\"%s\"%s\n",
+			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d ADD dn=\"%s\"%s\n",
 							 pb->pb_conn->c_connid,
 							 operation->o_opid,
 							 slapi_entry_get_dn_const(e),
diff --git a/ldap/servers/slapd/auth.c b/ldap/servers/slapd/auth.c
index c787dd4..da1b586 100644
--- a/ldap/servers/slapd/auth.c
+++ b/ldap/servers/slapd/auth.c
@@ -366,7 +366,7 @@ handle_bad_certificate (void* clientData, PRFileDesc *prfd)
     char* subject = subject_of (clientCert);
     char* issuer  = issuer_of  (clientCert);
     slapi_log_access( LDAP_DEBUG_STATS,
-	       "conn=%" NSPRIu64 " " SLAPI_COMPONENT_NAME_NSPR " error %i (%s); unauthenticated client %s; issuer %s\n",
+	       "conn=%" PRIu64 " " SLAPI_COMPONENT_NAME_NSPR " error %i (%s); unauthenticated client %s; issuer %s\n",
 	       conn->c_connid, errorCode, slapd_pr_strerror(errorCode),
 	       subject ? escape_string( subject, sbuf ) : "NULL",
 	       issuer  ? escape_string( issuer,  ibuf ) : "NULL" );
@@ -402,7 +402,7 @@ handle_handshake_done (PRFileDesc *prfd, void* clientData)
 	if ( (slapd_ssl_getChannelInfo (prfd, &channelInfo, sizeof(channelInfo))) != SECSuccess ) {
 		PRErrorCode errorCode = PR_GetError();
 		slapi_log_access (LDAP_DEBUG_STATS,
-			"conn=%" NSPRIu64 " SSL failed to obtain channel info; "
+			"conn=%" PRIu64 " SSL failed to obtain channel info; "
 			SLAPI_COMPONENT_NAME_NSPR " error %i (%s)\n",
 			conn->c_connid, errorCode, slapd_pr_strerror(errorCode));
 		goto done;
@@ -411,7 +411,7 @@ handle_handshake_done (PRFileDesc *prfd, void* clientData)
 			!= SECSuccess) {
 		PRErrorCode errorCode = PR_GetError();
 		slapi_log_access (LDAP_DEBUG_STATS,
-			"conn=%" NSPRIu64 " SSL failed to obtain cipher info; "
+			"conn=%" PRIu64 " SSL failed to obtain cipher info; "
 			SLAPI_COMPONENT_NAME_NSPR " error %i (%s)\n",
 			conn->c_connid, errorCode, slapd_pr_strerror(errorCode));
 		goto done;
@@ -432,14 +432,14 @@ handle_handshake_done (PRFileDesc *prfd, void* clientData)
 
     if (config_get_SSLclientAuth() == SLAPD_SSLCLIENTAUTH_OFF ) {
         (void) slapi_getSSLVersion_str(channelInfo.protocolVersion, sslversion, sizeof(sslversion));
-        slapi_log_access (LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " %s %i-bit %s\n",
+        slapi_log_access (LDAP_DEBUG_STATS, "conn=%" PRIu64 " %s %i-bit %s\n",
                 conn->c_connid, 
                 sslversion, keySize, cipher ? cipher : "NULL" );
         goto done;
     }
     if (clientCert == NULL) {
         (void) slapi_getSSLVersion_str(channelInfo.protocolVersion, sslversion, sizeof(sslversion));
-        slapi_log_access (LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " %s %i-bit %s\n",
+        slapi_log_access (LDAP_DEBUG_STATS, "conn=%" PRIu64 " %s %i-bit %s\n",
                 conn->c_connid, 
                 sslversion, keySize, cipher ? cipher : "NULL" );
     } else {
@@ -448,7 +448,7 @@ handle_handshake_done (PRFileDesc *prfd, void* clientData)
             (void) slapi_getSSLVersion_str(channelInfo.protocolVersion,
                                                  sslversion, sizeof(sslversion));
             slapi_log_access( LDAP_DEBUG_STATS,
-                       "conn=%" NSPRIu64 " %s %i-bit %s; missing subject\n",
+                       "conn=%" PRIu64 " %s %i-bit %s; missing subject\n",
                        conn->c_connid, 
                        sslversion, keySize, cipher ? cipher : "NULL");
             goto done;
@@ -459,7 +459,7 @@ handle_handshake_done (PRFileDesc *prfd, void* clientData)
             (void) slapi_getSSLVersion_str(channelInfo.protocolVersion,
                                                  sslversion, sizeof(sslversion));
             slapi_log_access( LDAP_DEBUG_STATS,
-                        "conn=%" NSPRIu64 " %s %i-bit %s; client %s; issuer %s\n",
+                        "conn=%" PRIu64 " %s %i-bit %s; client %s; issuer %s\n",
                         conn->c_connid,
                         sslversion, keySize, cipher ? cipher : "NULL",
                         subject ? escape_string( subject, sbuf ) : "NULL",
@@ -503,14 +503,14 @@ handle_handshake_done (PRFileDesc *prfd, void* clientData)
         (void) slapi_getSSLVersion_str(channelInfo.protocolVersion,
                                              sslversion, sizeof(sslversion));
         slapi_log_access (LDAP_DEBUG_STATS, 
-                          "conn=%" NSPRIu64 " %s client bound as %s\n",
+                          "conn=%" PRIu64 " %s client bound as %s\n",
                           conn->c_connid,
                           sslversion, clientDN);
     } else if (clientCert != NULL) {
         (void) slapi_getSSLVersion_str(channelInfo.protocolVersion,
                                              sslversion, sizeof(sslversion));
         slapi_log_access (LDAP_DEBUG_STATS,
-                          "conn=%" NSPRIu64 " %s failed to map client "
+                          "conn=%" PRIu64 " %s failed to map client "
                           "certificate to LDAP DN (%s)\n",
                           conn->c_connid,
                           sslversion, extraErrorMsg);
diff --git a/ldap/servers/slapd/back-ldbm/back-ldbm.h b/ldap/servers/slapd/back-ldbm/back-ldbm.h
index a5fc540..0bb15e3 100644
--- a/ldap/servers/slapd/back-ldbm/back-ldbm.h
+++ b/ldap/servers/slapd/back-ldbm/back-ldbm.h
@@ -28,21 +28,8 @@
 #endif
 #endif
 
-/* Required to get portable printf/scanf format macros */
-#ifdef HAVE_INTTYPES_H
-#include <inttypes.h>
-
-/* NSPR uses the print macros a bit differently than ANSI C.  We
- * need to use ll for a 64-bit integer, even when a long is 64-bit.
- */
-#undef PRIu64
-#define PRIu64  "llu"
-#undef PRI64
-#define PRI64   "ll"
-
-#else
-#error Need to define portable format macros such as PRIu64
-#endif /* HAVE_INTTYPES_H */
+/* Provides our int types and platform specific requirements. */
+#include <slapi_pal.h>
 
 /* A bunch of random system headers taken from all the source files, no source file should #include
    any system headers now */
@@ -162,11 +149,11 @@ typedef unsigned short u_int16_t;
 #define    DBVERSION_FILENAME    "DBVERSION"
 /* 0 here means to let the autotuning reset the value on first run */
 /* cache can't get any smaller than this (in bytes) */
-#define MINCACHESIZE             (size_t)512000
-#define DEFAULT_CACHE_SIZE       (size_t)0
+#define MINCACHESIZE             (uint64_t)512000
+#define DEFAULT_CACHE_SIZE       (uint64_t)0
 #define DEFAULT_CACHE_SIZE_STR   "0"
 #define DEFAULT_CACHE_ENTRIES    -1        /* no limit */
-#define DEFAULT_DNCACHE_SIZE     (size_t)16777216
+#define DEFAULT_DNCACHE_SIZE     (uint64_t)16777216
 #define DEFAULT_DNCACHE_SIZE_STR "16777216"
 #define DEFAULT_DNCACHE_MAXCOUNT -1        /* no limit */
 #define DEFAULT_DBCACHE_SIZE     33554432
diff --git a/ldap/servers/slapd/back-ldbm/cache.c b/ldap/servers/slapd/back-ldbm/cache.c
index ade2240..0f0cf3b 100644
--- a/ldap/servers/slapd/back-ldbm/cache.c
+++ b/ldap/servers/slapd/back-ldbm/cache.c
@@ -649,7 +649,7 @@ void cache_set_max_size(struct cache *cache, size_t bytes, int type)
     }
 }
 
-static void entrycache_set_max_size(struct cache *cache, size_t bytes)
+static void entrycache_set_max_size(struct cache *cache, uint64_t bytes)
 {
     struct backentry *eflush = NULL;
     struct backentry *eflushtemp = NULL;
@@ -659,16 +659,17 @@ static void entrycache_set_max_size(struct cache *cache, size_t bytes)
          * to happen. In that case, suppress this warning.
          */
         if (bytes > 0) {
-            slapi_log_err(SLAPI_LOG_WARNING, "entrycache_set_max_size", "Minimum cache size is %lu -- rounding up\n", MINCACHESIZE);
+            slapi_log_err(SLAPI_LOG_WARNING, "entrycache_set_max_size", "Minimum cache size is %"PRIu64" -- rounding up\n", MINCACHESIZE);
         }
         bytes = MINCACHESIZE;
     }
     cache_lock(cache);
     cache->c_maxsize = bytes;
-    LOG("entry cache size set to %lu\n", bytes);
+    LOG("entry cache size set to %"PRIu64"\n", bytes);
     /* check for full cache, and clear out if necessary */
-    if (CACHE_FULL(cache))
+    if (CACHE_FULL(cache)) {
        eflush = entrycache_flush(cache);
+    }
     while (eflush)
     {
         eflushtemp = BACK_LRU_NEXT(eflush, struct backentry *);
@@ -686,12 +687,11 @@ static void entrycache_set_max_size(struct cache *cache, size_t bytes)
     /* This may already have been called by one of the functions in
      * ldbm_instance_config
      */
-    if (! util_is_cachesize_sane(&bytes)) {
-       slapi_log_err(SLAPI_LOG_WARNING,
-                "entrycache_set_max_size", "Possible CONFIGURATION ERROR -- cachesize "
-                "(%lu) may be configured to use more than the available "
-                "physical memory.\n", bytes);
+    slapi_pal_meminfo *mi = spal_meminfo_get();
+    if (util_is_cachesize_sane(mi, &bytes) != UTIL_CACHESIZE_VALID) {
+       slapi_log_err(SLAPI_LOG_WARNING, "entrycache_set_max_size", "Cachesize (%"PRIu64") may use more than the available physical memory.\n", bytes);
     }
+    spal_meminfo_destroy(mi);
 }
 
 void cache_set_max_entries(struct cache *cache, long entries)
@@ -1597,7 +1597,7 @@ dn_same_id(const void *bdn, const void *k)
 }
 
 static void
-dncache_set_max_size(struct cache *cache, size_t bytes)
+dncache_set_max_size(struct cache *cache, uint64_t bytes)
 {
     struct backdn *dnflush = NULL;
     struct backdn *dnflushtemp = NULL;
@@ -1609,12 +1609,12 @@ dncache_set_max_size(struct cache *cache, size_t bytes)
     if (bytes < MINCACHESIZE) {
        bytes = MINCACHESIZE;
        slapi_log_err(SLAPI_LOG_WARNING,
-                "dncache_set_max_size", "Minimum cache size is %lu -- rounding up\n",
+                "dncache_set_max_size", "Minimum cache size is %"PRIu64" -- rounding up\n",
                 MINCACHESIZE);
     }
     cache_lock(cache);
     cache->c_maxsize = bytes;
-    LOG("entry cache size set to %lu\n", bytes);
+    LOG("entry cache size set to %"PRIu64"\n", bytes);
     /* check for full cache, and clear out if necessary */
     if (CACHE_FULL(cache)) {
        dnflush = dncache_flush(cache);
@@ -1636,12 +1636,12 @@ dncache_set_max_size(struct cache *cache, size_t bytes)
     /* This may already have been called by one of the functions in
      * ldbm_instance_config
      */
-    if (! util_is_cachesize_sane(&bytes)) {
-       slapi_log_err(SLAPI_LOG_WARNING,
-                "dncache_set_max_size", "Possible CONFIGURATION ERROR -- cachesize "
-                "(%lu) may be configured to use more than the available "
-                "physical memory.\n", bytes);
+
+    slapi_pal_meminfo *mi = spal_meminfo_get();
+    if (util_is_cachesize_sane(mi, &bytes) != UTIL_CACHESIZE_VALID) {
+       slapi_log_err(SLAPI_LOG_WARNING, "dncache_set_max_size", "Cachesize (%"PRIu64") may use more than the available physical memory.\n", bytes);
     }
+    spal_meminfo_destroy(mi);
 }
 
 /* remove a dn from the cache */
diff --git a/ldap/servers/slapd/back-ldbm/dblayer.c b/ldap/servers/slapd/back-ldbm/dblayer.c
index 507a3cc..3c1fbb0 100644
--- a/ldap/servers/slapd/back-ldbm/dblayer.c
+++ b/ldap/servers/slapd/back-ldbm/dblayer.c
@@ -1386,14 +1386,16 @@ dblayer_start(struct ldbminfo *li, int dbmode)
 
     /* Sanity check on cache size on platforms which allow us to figure out
      * the available phys mem */
-    if (!util_is_cachesize_sane(&(priv->dblayer_cachesize))) {
+    slapi_pal_meminfo *mi = spal_meminfo_get();
+    if (!util_is_cachesize_sane(mi, &(priv->dblayer_cachesize))) {
         /* Oops---looks like the admin misconfigured, let's warn them */
         slapi_log_err(SLAPI_LOG_WARNING,"dblayer_start", "Likely CONFIGURATION ERROR -"
                   "dbcachesize is configured to use more than the available "
-                  "physical memory, decreased to the largest available size (%lu bytes).\n",
+                  "physical memory, decreased to the largest available size (%"PRIu64" bytes).\n",
                   priv->dblayer_cachesize);
         li->li_dbcachesize = priv->dblayer_cachesize;
     }
+    spal_meminfo_destroy(mi);
 
     /* fill in DB_ENV stuff from the common configuration */
     return_value = dblayer_make_env(&pEnv, li);
@@ -1690,9 +1692,6 @@ dblayer_start(struct ldbminfo *li, int dbmode)
  *    nsslapd-import-cache-autosize: 0
  * get the nsslapd-import-cachesize.
  * Calculate the memory size left after allocating the import cache size.
- * If the size is less than the hard limit, it issues an error and quit.
- * If the size is greater than the hard limit and less than the soft limit,
- * it issues a warning, but continues the import task.
  *
  * Note: this function is called only if the import is executed as a stand
  * alone command line (ldif2db).
@@ -1700,27 +1699,17 @@ dblayer_start(struct ldbminfo *li, int dbmode)
 int
 check_and_set_import_cache(struct ldbminfo *li)
 {
-    size_t import_pages = 0;
-    size_t pagesize, pages, procpages, availpages;
-    size_t soft_limit = 0;
-    size_t hard_limit = 0;
-    size_t page_delta = 0;
+    uint64_t import_cache = 0;
     char s[64];   /* big enough to hold %ld */
+    /* Get our platform memory values. */
+    slapi_pal_meminfo *mi = spal_meminfo_get();
 
-    if (util_info_sys_pages(&pagesize, &pages, &procpages, &availpages) != 0 || 0 == pagesize || 0 == pages) {
-        slapi_log_err(SLAPI_LOG_ERR, "check_and_set_import_cache",
-                       "Failed to get pagesize: %ld or pages: %ld\n",
-                       pagesize, pages);
+    if (mi == NULL) {
+        slapi_log_err(SLAPI_LOG_ERR, "check_and_set_import_cache", "Failed to get system memory infomation\n");
         return ENOENT;
     }
-    slapi_log_err(SLAPI_LOG_INFO, "check_and_set_import_cache",
-                  "pagesize: %ld, pages: %ld, procpages: %ld\n",
-                  pagesize, pages, procpages);
+    slapi_log_err(SLAPI_LOG_INFO, "check_and_set_import_cache", "pagesize: %"PRIu64", available bytes %"PRIu64", process usage %"PRIu64" \n", mi->pagesize_bytes, mi->system_available_bytes, mi->process_consumed_bytes);
 
-    /* Soft limit: pages equivalent to 1GB (defined in dblayer.h) */
-    soft_limit = (DBLAYER_IMPORTCACHESIZE_SL*1024) / (pagesize/1024);
-    /* Hard limit: pages equivalent to 100MB (defined in dblayer.h) */
-    hard_limit = (DBLAYER_IMPORTCACHESIZE_HL*1024) / (pagesize/1024);
     /*
      * default behavior for ldif2db import cache,
      * nsslapd-import-cache-autosize==-1,
@@ -1741,48 +1730,29 @@ check_and_set_import_cache(struct ldbminfo *li)
 
     if (li->li_import_cache_autosize == 0) {
         /* user specified importCache */
-        import_pages = li->li_import_cachesize / pagesize;
+        import_cache = li->li_import_cachesize;
 
     } else {
         /* autosizing importCache */
         /* ./125 instead of ./100 is for adjusting the BDB overhead. */
-#ifdef LINUX
-        /* On linux, availpages is correct so we should use it! */
-        import_pages = (li->li_import_cache_autosize * availpages) / 125;
-#else
-        import_pages = (li->li_import_cache_autosize * pages) / 125;
-#endif
+        import_cache = (li->li_import_cache_autosize * mi->system_available_bytes) / 125;
     }
 
-    page_delta = pages - import_pages;
-    if (page_delta < hard_limit) {
-        slapi_log_err(SLAPI_LOG_ERR, 
-            "check_and_set_import_cache", "After allocating import cache %ldKB, "
-            "the available memory is %ldKB, "
-            "which is less than the hard limit %ldKB. "
-            "Please decrease the import cache size and rerun import.\n",
-            import_pages*(pagesize/1024), page_delta*(pagesize/1024),
-            hard_limit*(pagesize/1024));
+    if (util_is_cachesize_sane(mi, &import_cache) == UTIL_CACHESIZE_ERROR) {
+
+        slapi_log_err(SLAPI_LOG_INFO, "check_and_set_import_cache", "Import failed to run: unable to validate system memory limits.\n");
+        spal_meminfo_destroy(mi);
         return ENOMEM;
     }
-    if (page_delta < soft_limit) {
-        slapi_log_err(SLAPI_LOG_WARNING, 
-            "check_and_set_import_cache", "After allocating import cache %ldKB, "
-            "the available memory is %ldKB, "
-            "which is less than the soft limit %ldKB. "
-            "You may want to decrease the import cache size and "
-            "rerun import.\n",
-            import_pages*(pagesize/1024), page_delta*(pagesize/1024),
-            soft_limit*(pagesize/1024));
-    }
 
-    slapi_log_err(SLAPI_LOG_INFO, "check_and_set_import_cache", "Import allocates %ldKB import cache.\n", 
-                  import_pages*(pagesize/1024));
-    if (li->li_import_cache_autosize > 0) { /* import cache autosizing */
+    slapi_log_err(SLAPI_LOG_INFO, "check_and_set_import_cache", "Import allocates %"PRIu64"KB import cache.\n", import_cache / 1024);
+    if (li->li_import_cache_autosize > 0) {
+        /* import cache autosizing */
         /* set the calculated import cache size to the config */
-        sprintf(s, "%lu", (unsigned long)(import_pages * pagesize));
+        sprintf(s, "%"PRIu64, import_cache);
         ldbm_config_internal_set(li, CONFIG_IMPORT_CACHESIZE, s);
     }
+    spal_meminfo_destroy(mi);
     return 0;
 }
 
diff --git a/ldap/servers/slapd/back-ldbm/dblayer.h b/ldap/servers/slapd/back-ldbm/dblayer.h
index e4307fc..816c943 100644
--- a/ldap/servers/slapd/back-ldbm/dblayer.h
+++ b/ldap/servers/slapd/back-ldbm/dblayer.h
@@ -68,14 +68,6 @@
 #define	DB_REGION_NAME	25		/* DB: named regions, no backing file. */
 #endif
 
-/* Used in check_and_set_import_cache */
-/* After allocating the import cache, free memory must be left more than
- * the hard limit to run import. */
-/* If the free memory size left is greater than hard limit and less than
- * soft limit, the import utility issues a warning, but it runs */
-#define DBLAYER_IMPORTCACHESIZE_HL 100  /* import cache hard limit 100MB */
-#define DBLAYER_IMPORTCACHESIZE_SL 1024 /* import cache soft limit 1GB */
-
 struct dblayer_private_env {
 	DB_ENV	*dblayer_DB_ENV;
 	Slapi_RWLock * dblayer_env_lock;
diff --git a/ldap/servers/slapd/back-ldbm/import-threads.c b/ldap/servers/slapd/back-ldbm/import-threads.c
index 087103b..ab32e0a 100644
--- a/ldap/servers/slapd/back-ldbm/import-threads.c
+++ b/ldap/servers/slapd/back-ldbm/import-threads.c
@@ -3979,7 +3979,7 @@ _get_import_entryusn(ImportJob *job, Slapi_Value **usn_value)
              * Use the counter which stores the old DB's
              * next entryusn. */
             PR_snprintf(counter_buf, sizeof(counter_buf),
-                    "%" NSPRIu64, slapi_counter_get_value(be->be_usn_counter));
+                    "%" PRIu64, slapi_counter_get_value(be->be_usn_counter));
         } else {
             /* import_init value is digit.
              * Initialize the entryusn values with the digit */
diff --git a/ldap/servers/slapd/back-ldbm/import.c b/ldap/servers/slapd/back-ldbm/import.c
index d0cef1a..7161bac 100644
--- a/ldap/servers/slapd/back-ldbm/import.c
+++ b/ldap/servers/slapd/back-ldbm/import.c
@@ -84,17 +84,19 @@ static int import_fifo_init(ImportJob *job)
 int import_fifo_validate_capacity_or_expand(ImportJob *job, size_t entrysize) {
     int result = 1;
     /* We shoot for four times as much to start with. */
-    size_t request = entrysize * 4;
-    int sane = 0;
+    uint64_t request = entrysize * 4;
+    util_cachesize_result sane;
 
     if (entrysize > job->fifo.bsize) {
         /* Check the amount of memory on the system */
-        sane = util_is_cachesize_sane(&request);
-        if (!sane && entrysize <= request) {
+        slapi_pal_meminfo *mi = spal_meminfo_get();
+        sane = util_is_cachesize_sane(mi, &request);
+        spal_meminfo_destroy(mi);
+        if (sane == UTIL_CACHESIZE_REDUCED && entrysize <= request) {
             /* Did the amount cachesize set still exceed entrysize? It'll do ... */
             job->fifo.bsize = request;
             result = 0;
-        } else if (!sane) {
+        } else if (sane != UTIL_CACHESIZE_VALID) {
             /* Can't allocate! No!!! */
             result = 1;
         } else {
diff --git a/ldap/servers/slapd/back-ldbm/ldbm_config.c b/ldap/servers/slapd/back-ldbm/ldbm_config.c
index dfe7a13..d5120d3 100644
--- a/ldap/servers/slapd/back-ldbm/ldbm_config.c
+++ b/ldap/servers/slapd/back-ldbm/ldbm_config.c
@@ -403,8 +403,8 @@ static int ldbm_config_dbcachesize_set(void *arg, void *value, char *errorbuf, i
 {
     struct ldbminfo *li = (struct ldbminfo *) arg;
     int retval = LDAP_SUCCESS;
-    size_t val = (size_t)value;
-    size_t delta = (size_t)value;
+    uint64_t val = (size_t)value;
+    uint64_t delta = (size_t)value;
 
     /* There is an error here. We check the new val against our current mem-alloc 
      * Issue is that we already are using system pages, so while our value *might*
@@ -430,7 +430,13 @@ static int ldbm_config_dbcachesize_set(void *arg, void *value, char *errorbuf, i
             val = DBDEFMINSIZ;
         } else if (val > li->li_dbcachesize) {
             delta = val - li->li_dbcachesize;
-            if (!util_is_cachesize_sane(&delta)){
+
+            util_cachesize_result sane;
+            slapi_pal_meminfo *mi = spal_meminfo_get();
+            sane = util_is_cachesize_sane(mi, &delta);
+            spal_meminfo_destroy(mi);
+
+            if (sane != UTIL_CACHESIZE_VALID){
                 slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE, "Error: nsslapd-dbcachesize value is too large.");
                 slapi_log_err(SLAPI_LOG_ERR, "ldbm_config_dbcachesize_set",
                         "nsslapd-dbcachesize value is too large.\n");
@@ -1086,7 +1092,7 @@ static int ldbm_config_db_cache_set(void *arg, void *value, char *errorbuf, int
     struct ldbminfo *li = (struct ldbminfo *) arg;
     int retval = LDAP_SUCCESS;
     int val = ((uintptr_t)value);
-    size_t delta = 0;
+    uint64_t delta = 0;
 
     /* There is an error here. We check the new val against our current mem-alloc 
      * Issue is that we already are using system pages, so while our value *might*
@@ -1101,7 +1107,13 @@ static int ldbm_config_db_cache_set(void *arg, void *value, char *errorbuf, int
     if (apply) {
         if (val > li->li_dblayer_private->dblayer_cache_config) {
             delta = val - li->li_dblayer_private->dblayer_cache_config;
-            if (!util_is_cachesize_sane(&delta)){
+            util_cachesize_result sane;
+
+            slapi_pal_meminfo *mi = spal_meminfo_get();
+            sane = util_is_cachesize_sane(mi, &delta);
+            spal_meminfo_destroy(mi);
+
+            if (sane != UTIL_CACHESIZE_VALID){
                 slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE, "Error: db cachesize value is too large");
                 slapi_log_err(SLAPI_LOG_ERR,"ldbm_config_db_cache_set", "db cachesize value is too large.\n");
                 return LDAP_UNWILLING_TO_PERFORM;
@@ -1219,7 +1231,7 @@ static int ldbm_config_import_cachesize_set(void *arg, void *value, char *errorb
 {
     struct ldbminfo *li = (struct ldbminfo *)arg;
     size_t val = (size_t)value;
-    size_t delta = (size_t)value;
+    uint64_t delta = (size_t)value;
     /* There is an error here. We check the new val against our current mem-alloc 
      * Issue is that we already are using system pages, so while our value *might*
      * be valid, we may reject it here due to the current procs page usage.
@@ -1232,7 +1244,13 @@ static int ldbm_config_import_cachesize_set(void *arg, void *value, char *errorb
     if (apply){
         if (val > li->li_import_cachesize) {
             delta = val - li->li_import_cachesize;
-            if (!util_is_cachesize_sane(&delta)){
+
+            util_cachesize_result sane;
+            slapi_pal_meminfo *mi = spal_meminfo_get();
+            sane = util_is_cachesize_sane(mi, &delta);
+            spal_meminfo_destroy(mi);
+
+            if (sane != UTIL_CACHESIZE_VALID){
                 slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE, "Error: import cachesize value is too large.");
                 slapi_log_err(SLAPI_LOG_ERR,"ldbm_config_import_cachesize_set",
                         "Import cachesize value is too large.\n");
diff --git a/ldap/servers/slapd/back-ldbm/ldbm_delete.c b/ldap/servers/slapd/back-ldbm/ldbm_delete.c
index 92d982e..0b0b37e 100644
--- a/ldap/servers/slapd/back-ldbm/ldbm_delete.c
+++ b/ldap/servers/slapd/back-ldbm/ldbm_delete.c
@@ -107,7 +107,7 @@ ldbm_back_delete( Slapi_PBlock *pb )
 
 	if (pb->pb_conn)
 	{
-		slapi_log_err(SLAPI_LOG_TRACE, "ldbm_back_delete", "Enter conn=%" NSPRIu64 " op=%d\n",
+		slapi_log_err(SLAPI_LOG_TRACE, "ldbm_back_delete", "Enter conn=%" PRIu64 " op=%d\n",
 				pb->pb_conn->c_connid, operation->o_opid);
 	}
 
@@ -1493,7 +1493,7 @@ diskfull_return:
 	slapi_sdn_done(&parentsdn);
 	if (pb->pb_conn)
 	{
-		slapi_log_err(SLAPI_LOG_TRACE, "ldbm_back_delete", "leave conn=%" NSPRIu64 " op=%d\n",
+		slapi_log_err(SLAPI_LOG_TRACE, "ldbm_back_delete", "leave conn=%" PRIu64 " op=%d\n",
 				pb->pb_conn->c_connid, operation->o_opid);
 	}
 
diff --git a/ldap/servers/slapd/back-ldbm/ldbm_instance_config.c b/ldap/servers/slapd/back-ldbm/ldbm_instance_config.c
index e03954d..62cdbc3 100644
--- a/ldap/servers/slapd/back-ldbm/ldbm_instance_config.c
+++ b/ldap/servers/slapd/back-ldbm/ldbm_instance_config.c
@@ -92,7 +92,7 @@ ldbm_instance_config_cachememsize_set(void *arg, void *value, char *errorbuf, in
     ldbm_instance *inst = (ldbm_instance *) arg;
     int retval = LDAP_SUCCESS;
     size_t val = (size_t) value;
-    size_t delta = 0;
+    uint64_t delta = 0;
 
     /* Do whatever we can to make sure the data is ok. */
     /* There is an error here. We check the new val against our current mem-alloc 
@@ -108,7 +108,13 @@ ldbm_instance_config_cachememsize_set(void *arg, void *value, char *errorbuf, in
     if (apply) {
         if (val > inst->inst_cache.c_maxsize) {
             delta = val - inst->inst_cache.c_maxsize;
-            if (!util_is_cachesize_sane(&delta)){
+
+            util_cachesize_result sane;
+            slapi_pal_meminfo *mi = spal_meminfo_get();
+            sane = util_is_cachesize_sane(mi, &delta);
+            spal_meminfo_destroy(mi);
+
+            if (sane != UTIL_CACHESIZE_VALID){
                 slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE, "Error: cachememsize value is too large.");
                 slapi_log_err(SLAPI_LOG_ERR, "ldbm_instance_config_cachememsize_set", "cachememsize value is too large.\n");
                 return LDAP_UNWILLING_TO_PERFORM;
@@ -134,7 +140,7 @@ ldbm_instance_config_dncachememsize_set(void *arg, void *value, char *errorbuf,
     ldbm_instance *inst = (ldbm_instance *) arg;
     int retval = LDAP_SUCCESS;
     size_t val = (size_t)value;
-    size_t delta = 0;
+    uint64_t delta = 0;
 
     /* Do whatever we can to make sure the data is ok. */
     /* There is an error here. We check the new val against our current mem-alloc 
@@ -150,7 +156,13 @@ ldbm_instance_config_dncachememsize_set(void *arg, void *value, char *errorbuf,
     if (apply) {
         if (val > inst->inst_dncache.c_maxsize) {
             delta = val - inst->inst_dncache.c_maxsize;
-            if (!util_is_cachesize_sane(&delta)){
+
+            util_cachesize_result sane;
+            slapi_pal_meminfo *mi = spal_meminfo_get();
+            sane = util_is_cachesize_sane(mi, &delta);
+            spal_meminfo_destroy(mi);
+
+            if (sane != UTIL_CACHESIZE_VALID){
                 slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE,
                     "Error: dncachememsize value is too large.");
                 slapi_log_err(SLAPI_LOG_ERR,"ldbm_instance_config_dncachememsize_set",
diff --git a/ldap/servers/slapd/back-ldbm/ldbm_modrdn.c b/ldap/servers/slapd/back-ldbm/ldbm_modrdn.c
index a78d850..533273b 100644
--- a/ldap/servers/slapd/back-ldbm/ldbm_modrdn.c
+++ b/ldap/servers/slapd/back-ldbm/ldbm_modrdn.c
@@ -142,7 +142,7 @@ ldbm_back_modrdn( Slapi_PBlock *pb )
 
     if (pb->pb_conn)
     {
-        slapi_log_err(SLAPI_LOG_TRACE, "ldbm_back_modrdn", "enter conn=%" NSPRIu64 " op=%d\n",
+        slapi_log_err(SLAPI_LOG_TRACE, "ldbm_back_modrdn", "enter conn=%" PRIu64 " op=%d\n",
                 pb->pb_conn->c_connid, operation->o_opid);
     }
 
@@ -1539,7 +1539,7 @@ common_return:
     if (pb->pb_conn)
     {
         slapi_log_err(SLAPI_LOG_TRACE, "ldbm_back_modrdn",
-                "leave conn=%" NSPRIu64 " op=%d\n",
+                "leave conn=%" PRIu64 " op=%d\n",
                 pb->pb_conn->c_connid, operation->o_opid);
     }
     return retval;
diff --git a/ldap/servers/slapd/back-ldbm/ldbm_search.c b/ldap/servers/slapd/back-ldbm/ldbm_search.c
index a6c3b74..cfb0d6b 100644
--- a/ldap/servers/slapd/back-ldbm/ldbm_search.c
+++ b/ldap/servers/slapd/back-ldbm/ldbm_search.c
@@ -407,7 +407,7 @@ ldbm_back_search( Slapi_PBlock *pb )
                     slapi_pblock_get(pb, SLAPI_OPERATION_ID, &op_id);
 
                     slapi_log_err(SLAPI_LOG_WARNING,
-                            "ldbm_back_search", "Sort control ignored for conn=%" NSPRIu64 " op=%d\n",
+                            "ldbm_back_search", "Sort control ignored for conn=%" PRIu64 " op=%d\n",
                             conn_id, op_id);                    
                 }
             } else {
@@ -442,7 +442,7 @@ ldbm_back_search( Slapi_PBlock *pb )
                         slapi_pblock_get(pb, SLAPI_OPERATION_ID, &op_id);
 
                         slapi_log_err(SLAPI_LOG_WARNING,
-                                "ldbm_back_search", "VLV control ignored for conn=%" NSPRIu64 " op=%d\n",
+                                "ldbm_back_search", "VLV control ignored for conn=%" PRIu64 " op=%d\n",
                                 conn_id, op_id);             
                     }
 
diff --git a/ldap/servers/slapd/back-ldbm/misc.c b/ldap/servers/slapd/back-ldbm/misc.c
index 5268087..7192b3a 100644
--- a/ldap/servers/slapd/back-ldbm/misc.c
+++ b/ldap/servers/slapd/back-ldbm/misc.c
@@ -54,7 +54,7 @@ void ldbm_log_access_message(Slapi_PBlock *pblock,char *string)
         return;
     }
     operation_id = operation->o_opid;
-    slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d %s\n",
+    slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d %s\n",
                      connection_id, operation_id, string);
 }
 
diff --git a/ldap/servers/slapd/back-ldbm/monitor.c b/ldap/servers/slapd/back-ldbm/monitor.c
index 757792b..c58b069 100644
--- a/ldap/servers/slapd/back-ldbm/monitor.c
+++ b/ldap/servers/slapd/back-ldbm/monitor.c
@@ -101,9 +101,9 @@ int ldbm_back_monitor_instance_search(Slapi_PBlock *pb, Slapi_Entry *e,
         /* fetch cache statistics */
         cache_get_stats(&(inst->inst_dncache), &hits, &tries, 
                         &nentries, &maxentries, &size, &maxsize);
-        sprintf(buf, "%" NSPRIu64, hits);
+        sprintf(buf, "%" PRIu64, hits);
         MSET("dnCacheHits");
-        sprintf(buf, "%" NSPRIu64, tries);
+        sprintf(buf, "%" PRIu64, tries);
         MSET("dnCacheTries");
         sprintf(buf, "%lu", (unsigned long)(100.0*(double)hits / (double)(tries > 0 ? tries : 1)));
         MSET("dnCacheHitRatio");
@@ -119,11 +119,11 @@ int ldbm_back_monitor_instance_search(Slapi_PBlock *pb, Slapi_Entry *e,
     /* normalized dn cache stats */
     if(ndn_cache_started()){
         ndn_cache_get_stats(&hits, &tries, &size, &maxsize, &count);
-        sprintf(buf, "%" NSPRIu64, tries);
+        sprintf(buf, "%" PRIu64, tries);
         MSET("normalizedDnCacheTries");
-        sprintf(buf, "%" NSPRIu64, hits);
+        sprintf(buf, "%" PRIu64, hits);
         MSET("normalizedDnCacheHits");
-        sprintf(buf, "%" NSPRIu64, (tries - hits));
+        sprintf(buf, "%" PRIu64, (tries - hits));
         MSET("normalizedDnCacheMisses");
         sprintf(buf, "%lu", (unsigned long)(100.0*(double)hits / (double)(tries > 0 ? tries : 1)));
         MSET("normalizedDnCacheHitRatio");
diff --git a/ldap/servers/slapd/back-ldbm/perfctrs.h b/ldap/servers/slapd/back-ldbm/perfctrs.h
index 57be1d1..64c79e1 100644
--- a/ldap/servers/slapd/back-ldbm/perfctrs.h
+++ b/ldap/servers/slapd/back-ldbm/perfctrs.h
@@ -11,7 +11,7 @@
 #  include <config.h>
 #endif
 
-#include <inttypes.h>
+#include <slapi_pal.h>
 
 /* Structure definition for performance data */
 /* This stuff goes in shared memory, so make sure the packing is consistent */
diff --git a/ldap/servers/slapd/back-ldbm/start.c b/ldap/servers/slapd/back-ldbm/start.c
index 1ae9858..a207bd8 100644
--- a/ldap/servers/slapd/back-ldbm/start.c
+++ b/ldap/servers/slapd/back-ldbm/start.c
@@ -32,34 +32,25 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
     Object *inst_obj = NULL;
     ldbm_instance *inst = NULL;
     /* size_t is a platform unsigned int, IE uint64_t */
-    size_t total_cache_size = 0;
-    size_t pagesize = 0;
-    size_t pages = 0;
-    size_t procpages __attribute__((unused)) = 0;
-    size_t availpages = 0;
-    size_t cache_size_to_configure = 0;
-    size_t zone_pages = 0;
-    size_t db_pages = 0;
-    size_t entry_pages = 0;
-    size_t import_pages = 0;
-    size_t zone_size = 0;
-    size_t import_size = 0;
-    size_t cache_size = 0;
-    size_t db_size = 0;
+    uint64_t total_cache_size = 0;
+    uint64_t entry_size = 0;
+    uint64_t zone_size = 0;
+    uint64_t import_size = 0;
+    uint64_t cache_size = 0;
+    uint64_t db_size = 0;
     /* For clamping the autotune value to a 64Mb boundary */
-    size_t clamp_pages = 0;
-    size_t clamp_div = 0;
-    size_t clamp_mod = 0;
+    uint64_t clamp_div = 0;
     /* Backend count */
-    size_t backend_count = 0;
+    uint64_t backend_count = 0;
 
     int_fast32_t autosize_percentage = 0;
     int_fast32_t autosize_db_percentage_split = 0;
     int_fast32_t import_percentage = 0;
-    int32_t issane = 0;
+    util_cachesize_result issane;
     char *msg = ""; /* This will be set by one of the two cache sizing paths below. */
     char size_to_str[32];    /* big enough to hold %ld */
 
+
     /* == Begin autotune == */
 
     /*
@@ -120,42 +111,34 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
         return SLAPI_FAIL_GENERAL;
     }
 
-    if (util_info_sys_pages(&pagesize, &pages, &procpages, &availpages) != 0) {
+    /* Get our platform memory values. */
+    slapi_pal_meminfo *mi = spal_meminfo_get();
+    if (mi == NULL) {
         slapi_log_err(SLAPI_LOG_CRIT, "ldbm_back_start", "Unable to determine system page limits\n");
         return SLAPI_FAIL_GENERAL;
     }
 
-    if (pagesize == 0) {
-        /* If this happens, we are in a very bad state indeed... */
-        slapi_log_err(SLAPI_LOG_CRIT, "ldbm_back_start", "Unable to determine system page size\n");
-        return SLAPI_FAIL_GENERAL;
-    }
-
     /* calculate the needed values */
-    zone_pages = (autosize_percentage * pages) / 100;
-    zone_size = zone_pages * pagesize;
+    zone_size = (autosize_percentage * mi->system_total_bytes) / 100;
     /* This is how much we "might" use, lets check it's sane. */
     /* In the case it is not, this will *reduce* the allocation */
-    issane = util_is_cachesize_sane(&zone_size);
-    if (!issane) {
+    issane = util_is_cachesize_sane(mi, &zone_size);
+    if (issane == UTIL_CACHESIZE_REDUCED) {
         slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "Your autosized cache values have been reduced. Likely your nsslapd-cache-autosize percentage is too high.\n");
         slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "%s", msg);
     }
     /* It's valid, lets divide it up and set according to user prefs */
-    zone_pages = zone_size / pagesize;
-    db_pages = (autosize_db_percentage_split * zone_pages) / 100;
+    db_size = (autosize_db_percentage_split * zone_size) / 100;
 
     /* Cap the DB size at 512MB, as this doesn't help perf much more (lkrispen's advice) */
-    if ((db_pages * pagesize) > (512 * MEGABYTE)) {
-        db_pages = (512 * MEGABYTE) / pagesize;
+    if (db_size > (512 * MEGABYTE)) {
+        db_size = (512 * MEGABYTE);
     }
 
     if (backend_count > 0 ) {
         /* Number of entry cache pages per backend. */
-        entry_pages = (zone_pages - db_pages) / backend_count;
+        entry_size = (zone_size - db_size) / backend_count;
         /* Now, clamp this value to a 64mb boundary. */
-        /* How many pages are in 64mb? */
-        clamp_pages = (64 * MEGABYTE) / pagesize;
         /* Now divide the entry pages by this, and also mod. If mod != 0, we need
          * to add 1 to the diveded number. This should give us:
          * 510 * 1024 * 1024 == 510MB
@@ -166,17 +149,15 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
          * 130560 % 16384 = 15872 which is != 0
          * therfore 7 + 1, aka 8 * 16384 = 131072 pages = 536870912 bytes = 512MB.
          */
-        clamp_div = entry_pages / clamp_pages;
-        clamp_mod = entry_pages % clamp_pages;
-        if (clamp_mod != 0) {
-            /* If we want to clamp down, remove this line. This would change the above from 510mb -> 448mb. */
-            clamp_div += 1;
-            entry_pages = clamp_div * clamp_pages;
+        if (entry_size % (64 * MEGABYTE) != 0) {
+            /* If we want to clamp down, remove the "+1". This would change the above from 510mb -> 448mb. */
+            clamp_div = (entry_size / (64 * MEGABYTE)) + 1;
+            entry_size = clamp_div * (64 * MEGABYTE);
         }
     }
 
-    slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "found %luk physical memory\n", pages*(pagesize/1024));
-    slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "found %luk avaliable\n", zone_pages*(pagesize/1024));
+    slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "found %luk physical memory\n", mi->system_total_bytes / 1024);
+    slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "found %luk avaliable\n", mi->system_available_bytes / 1024);
 
     /* We've now calculated the autotuning values. Do we need to apply it?
      * we use the logic of "if size is 0, or autosize is > 0. This way three
@@ -191,13 +172,12 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
 
     /* First, check the dbcache */
     if (li->li_dbcachesize == 0 || li->li_cache_autosize > 0) {
-        slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "cache autosizing: db cache: %luk\n", db_pages*(pagesize/1024));
-        cache_size_to_configure = (unsigned long)(db_pages * pagesize);
-        if (cache_size_to_configure < (500 * MEGABYTE)) {
-            cache_size_to_configure = (unsigned long)((db_pages * pagesize) / 1.25);
+        slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "cache autosizing: db cache: %luk\n", db_size / 1024);
+        if (db_size < (500 * MEGABYTE)) {
+            db_size = db_size / 1.25;
         }
         /* Have to set this value through text. */
-        sprintf(size_to_str, "%lu", cache_size_to_configure);
+        sprintf(size_to_str, "%" PRIu64 , db_size);
         ldbm_config_internal_set(li, CONFIG_DBCACHESIZE, size_to_str);
     }
     total_cache_size += li->li_dbcachesize;
@@ -205,7 +185,7 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
     /* For each backend */
     /*   apply the appropriate cache size if 0 */
     if (backend_count > 0 ) {
-        li->li_cache_autosize_ec = (unsigned long)entry_pages * pagesize;
+        li->li_cache_autosize_ec = entry_size;
     }
 
     for (inst_obj = objset_first_obj(li->li_instance_set); inst_obj;
@@ -220,7 +200,7 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
          * it's highly unlikely.
          */
         if (cache_size == 0 || cache_size == MINCACHESIZE || li->li_cache_autosize > 0) {
-            slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "cache autosizing: %s entry cache (%lu total): %luk\n", inst->inst_name, backend_count, entry_pages*(pagesize/1024));
+            slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "cache autosizing: %s entry cache (%lu total): %luk\n", inst->inst_name, backend_count, entry_size / 1024);
             cache_set_max_entries(&(inst->inst_cache), -1);
             cache_set_max_size(&(inst->inst_cache), li->li_cache_autosize_ec, CACHE_TYPE_ENTRY);
         }
@@ -229,8 +209,8 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
         db_size = dblayer_get_id2entry_size(inst);
         if (cache_size < db_size) {
             slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start",
-                  "%s: entry cache size %lu B is "
-                  "less than db size %lu B; "
+                  "%s: entry cache size %"PRIu64" B is "
+                  "less than db size %"PRIu64" B; "
                   "We recommend to increase the entry cache size "
                   "nsslapd-cachememsize.\n",
                   inst->inst_name, cache_size, db_size);
@@ -244,37 +224,36 @@ ldbm_back_start_autotune(struct ldbminfo *li) {
     /* autosizing importCache */
     if (li->li_import_cache_autosize > 0) {
         /* Use import percentage here, as it's been corrected for -1 behaviour */
-        import_pages = (import_percentage * pages) / 100;
-        import_size = import_pages * pagesize;
-        issane = util_is_cachesize_sane(&import_size);
-        if (!issane) {
+        import_size = (import_percentage * mi->system_total_bytes) / 100;
+        issane = util_is_cachesize_sane(mi, &import_size);
+        if (issane == UTIL_CACHESIZE_REDUCED) {
             slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "Your autosized import cache values have been reduced. Likely your nsslapd-import-cache-autosize percentage is too high.\n");
         }
         /* We just accept the reduced allocation here. */
-        import_pages = import_size / pagesize;
-        slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "cache autosizing: import cache: %luk\n",
-        import_pages*(pagesize/1024));
+        slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "cache autosizing: import cache: %"PRIu64"k\n", import_size / 1024);
 
-        sprintf(size_to_str, "%lu", (unsigned long)(import_pages * pagesize));
+        sprintf(size_to_str, "%"PRIu64, import_size);
         ldbm_config_internal_set(li, CONFIG_IMPORT_CACHESIZE, size_to_str);
     }
 
     /* Finally, lets check that the total result is sane. */
-    slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "total cache size: %lu B; \n", total_cache_size);
+    slapi_log_err(SLAPI_LOG_NOTICE, "ldbm_back_start", "total cache size: %"PRIu64" B; \n", total_cache_size);
 
-    issane = util_is_cachesize_sane(&total_cache_size);
-    if (!issane) {
+    issane = util_is_cachesize_sane(mi, &total_cache_size);
+    if (issane != UTIL_CACHESIZE_VALID) {
         /* Right, it's time to panic */
         slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "It is highly likely your memory configuration of all backends will EXCEED your systems memory.\n");
         slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "In a future release this WILL prevent server start up. You MUST alter your configuration.\n");
-        slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "Total entry cache size: %lu B; dbcache size: %lu B; available memory size: %lu B; \n",
-                  (PRUint64)total_cache_size, (PRUint64)li->li_dbcachesize, availpages * pagesize
+        slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "Total entry cache size: %"PRIu64" B; dbcache size: %"PRIu64" B; available memory size: %"PRIu64" B; \n",
+                    total_cache_size, (uint64_t)li->li_dbcachesize, mi->system_available_bytes
         );
         slapi_log_err(SLAPI_LOG_WARNING, "ldbm_back_start", "%s\n", msg);
         /* WB 2016 - This should be UNCOMMENTED in a future release */
         /* return SLAPI_FAIL_GENERAL; */
     }
 
+    spal_meminfo_destroy(mi);
+
     /* == End autotune == */
     return 0;
 }
diff --git a/ldap/servers/slapd/bind.c b/ldap/servers/slapd/bind.c
index f83df7d..648a0f9 100644
--- a/ldap/servers/slapd/bind.c
+++ b/ldap/servers/slapd/bind.c
@@ -853,25 +853,25 @@ log_bind_access (
 {
     if (method == LDAP_AUTH_SASL && saslmech && msg) {
         slapi_log_access( LDAP_DEBUG_STATS, 
-                          "conn=%" NSPRIu64 " op=%d BIND dn=\"%s\" "
+                          "conn=%" PRIu64 " op=%d BIND dn=\"%s\" "
                           "method=sasl version=%d mech=%s, %s\n",
                           pb->pb_conn->c_connid, pb->pb_op->o_opid, dn,
                           version, saslmech, msg );
     } else if (method == LDAP_AUTH_SASL && saslmech) {
         slapi_log_access( LDAP_DEBUG_STATS, 
-                          "conn=%" NSPRIu64 " op=%d BIND dn=\"%s\" "
+                          "conn=%" PRIu64 " op=%d BIND dn=\"%s\" "
                           "method=sasl version=%d mech=%s\n",
                           pb->pb_conn->c_connid, pb->pb_op->o_opid, dn,
                           version, saslmech );
     } else if (msg) {
         slapi_log_access( LDAP_DEBUG_STATS, 
-                          "conn=%" NSPRIu64 " op=%d BIND dn=\"%s\" "
+                          "conn=%" PRIu64 " op=%d BIND dn=\"%s\" "
                           "method=%" BERTAG_T " version=%d, %s\n",
                           pb->pb_conn->c_connid, pb->pb_op->o_opid, dn,
                           method, version, msg );
     } else {
         slapi_log_access( LDAP_DEBUG_STATS, 
-                          "conn=%" NSPRIu64 " op=%d BIND dn=\"%s\" "
+                          "conn=%" PRIu64 " op=%d BIND dn=\"%s\" "
                           "method=%" BERTAG_T " version=%d\n",
                           pb->pb_conn->c_connid, pb->pb_op->o_opid, dn,
                           method, version );
diff --git a/ldap/servers/slapd/compare.c b/ldap/servers/slapd/compare.c
index 07ded98..3c03053 100644
--- a/ldap/servers/slapd/compare.c
+++ b/ldap/servers/slapd/compare.c
@@ -111,7 +111,7 @@ do_compare( Slapi_PBlock *pb )
 	    rawdn, ava.ava_type, 0 );
 
 	slapi_log_access( LDAP_DEBUG_STATS,
-	    "conn=%" NSPRIu64 " op=%d CMP dn=\"%s\" attr=\"%s\"\n",
+	    "conn=%" PRIu64 " op=%d CMP dn=\"%s\" attr=\"%s\"\n",
 	    pb->pb_conn->c_connid, pb->pb_op->o_opid, dn, ava.ava_type );
 
 	/*
diff --git a/ldap/servers/slapd/connection.c b/ldap/servers/slapd/connection.c
index 7c83c66..359b59a 100644
--- a/ldap/servers/slapd/connection.c
+++ b/ldap/servers/slapd/connection.c
@@ -411,7 +411,7 @@ connection_reset(Connection* conn, int ns, PRNetAddr * from, int fromLen, int is
 
     /* log useful stuff to our access log */
     slapi_log_access( LDAP_DEBUG_STATS,
-        "conn=%" NSPRIu64 " fd=%d slot=%d %sconnection from %s to %s\n",
+        "conn=%" PRIu64 " fd=%d slot=%d %sconnection from %s to %s\n",
         conn->c_connid, conn->c_sd, ns, pTmp, str_ip, str_destip );
 
     /* initialize the remaining connection fields */
@@ -511,7 +511,7 @@ connection_need_new_password(const Connection *conn, const Operation *op, Slapi_
 		op->o_tag != LDAP_REQ_ABANDON && op->o_tag != LDAP_REQ_EXTENDED)
 	{
 		slapi_add_pwd_control ( pb, LDAP_CONTROL_PWEXPIRED, 0);	
-		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d %s\n",
+		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d %s\n",
 			pb->pb_conn->c_connid, pb->pb_op->o_opid,
 			"UNPROCESSED OPERATION - need new password" );
 		send_ldap_result( pb, LDAP_UNWILLING_TO_PERFORM, 
@@ -562,7 +562,7 @@ connection_dispatch_operation(Connection *conn, Operation *op, Slapi_PBlock *pb)
 	    (op->o_tag != LDAP_REQ_EXTENDED) && (op->o_tag != LDAP_REQ_UNBIND) &&
 	    (op->o_tag != LDAP_REQ_ABANDON)) {
 		slapi_log_access( LDAP_DEBUG_STATS,
-			"conn=%" NSPRIu64 " op=%d UNPROCESSED OPERATION"
+			"conn=%" PRIu64 " op=%d UNPROCESSED OPERATION"
 			" - Insufficient SSF (local_ssf=%d sasl_ssf=%d ssl_ssf=%d)\n",
 			conn->c_connid, op->o_opid, conn->c_local_ssf,
 			conn->c_sasl_ssf, conn->c_ssl_ssf );
@@ -591,7 +591,7 @@ connection_dispatch_operation(Connection *conn, Operation *op, Slapi_PBlock *pb)
 	    (op->o_tag != LDAP_REQ_ABANDON) && (op->o_tag != LDAP_REQ_SEARCH))))
 	{
 		slapi_log_access( LDAP_DEBUG_STATS,
-			"conn=%" NSPRIu64 " op=%d UNPROCESSED OPERATION"
+			"conn=%" PRIu64 " op=%d UNPROCESSED OPERATION"
 			" - Anonymous access not allowed\n",
 			conn->c_connid, op->o_opid );
 
@@ -650,7 +650,7 @@ connection_dispatch_operation(Connection *conn, Operation *op, Slapi_PBlock *pb)
 			int ret = setsockopt(conn->c_sd,IPPROTO_TCP,TCP_CORK,&i,sizeof(i));
 			if (ret < 0) {
 				slapi_log_err(SLAPI_LOG_ERR, "connection_dispatch_operation",
-					"Failed to set TCP_CORK on connection %" NSPRIu64 "\n",conn->c_connid);
+					"Failed to set TCP_CORK on connection %" PRIu64 "\n",conn->c_connid);
 			}
 			pop_cork = 1;
 		}
@@ -664,7 +664,7 @@ connection_dispatch_operation(Connection *conn, Operation *op, Slapi_PBlock *pb)
 			int ret = setsockopt(conn->c_sd,IPPROTO_TCP,TCP_CORK,&i,sizeof(i));
 			if (ret < 0) {
 				slapi_log_err(SLAPI_LOG_ERR, "connection_dispatch_operation",
-					"Failed to clear TCP_CORK on connection %" NSPRIu64 "\n",conn->c_connid);
+					"Failed to clear TCP_CORK on connection %" PRIu64 "\n",conn->c_connid);
 			}
 		}
 #endif
@@ -690,7 +690,7 @@ connection_dispatch_operation(Connection *conn, Operation *op, Slapi_PBlock *pb)
 
 	default:
 		slapi_log_err(SLAPI_LOG_ERR,
-		    "connection_dispatch_operation", "Ignoring unknown LDAP request (conn=%" NSPRIu64 ", tag=0x%lx)\n",
+		    "connection_dispatch_operation", "Ignoring unknown LDAP request (conn=%" PRIu64 ", tag=0x%lx)\n",
 		    conn->c_connid, op->o_tag);
 		break;
 	}
@@ -702,7 +702,7 @@ int connection_release_nolock_ext (Connection *conn, int release_only)
     if (conn->c_refcnt <= 0)
     {
         slapi_log_err(SLAPI_LOG_ERR, "connection_release_nolock_ext",
-		                "conn=%" NSPRIu64 " fd=%d Attempt to release connection that is not acquired\n",
+		                "conn=%" PRIu64 " fd=%d Attempt to release connection that is not acquired\n",
 		                conn->c_connid, conn->c_sd);
         PR_ASSERT (PR_FALSE);
         return -1;
@@ -734,7 +734,7 @@ int connection_acquire_nolock_ext (Connection *conn, int allow_when_closing)
     {
 	/* This may happen while other threads are still working on this connection */
         slapi_log_err(SLAPI_LOG_ERR, "connection_acquire_nolock_ext",
-		                "conn=%" NSPRIu64 " fd=%d Attempt to acquire connection in the closing state\n",
+		                "conn=%" PRIu64 " fd=%d Attempt to acquire connection in the closing state\n",
 		                conn->c_connid, conn->c_sd);
         return -1;
     }
@@ -1070,7 +1070,7 @@ get_next_from_buffer( void *buffer, size_t buffer_size, ber_len_t *lenp,
 		syserr = errno;
 		/* Bad stuff happened, like the client sent us some junk */
 		slapi_log_err(SLAPI_LOG_CONNS, "get_next_from_buffer",
-			"ber_get_next failed for connection %" NSPRIu64 "\n", conn->c_connid);
+			"ber_get_next failed for connection %" PRIu64 "\n", conn->c_connid);
 		/* reset private buffer */
 		conn->c_private->c_buffer_bytes = conn->c_private->c_buffer_offset = 0;
 
@@ -1232,7 +1232,7 @@ int connection_read_operation(Connection *conn, Operation *op, ber_tag_t *tag, i
 						/* Otherwise we loop, unless we exceeded the ioblock timeout */
 						if (waits_done > ioblocktimeout_waits) {
 							slapi_log_err(SLAPI_LOG_CONNS,"connection_read_operation",
-								"ioblocktimeout expired on connection %" NSPRIu64 "\n", conn->c_connid);
+								"ioblocktimeout expired on connection %" PRIu64 "\n", conn->c_connid);
 							disconnect_server_nomutex( conn, conn->c_connid, -1,
 									SLAPD_DISCONNECT_IO_TIMEOUT, 0 );
 							ret = CONN_DONE;
@@ -1253,19 +1253,19 @@ int connection_read_operation(Connection *conn, Operation *op, ber_tag_t *tag, i
 					err = PR_GetError();
 					syserr = PR_GetOSError();
 					slapi_log_err(SLAPI_LOG_ERR, "connection_read_operation",
-						"PR_Poll for connection %" NSPRIu64 " returns %d (%s)\n", conn->c_connid, err, slapd_pr_strerror( err ) );
+						"PR_Poll for connection %" PRIu64 " returns %d (%s)\n", conn->c_connid, err, slapd_pr_strerror( err ) );
 					/* If this happens we should close the connection */
 					disconnect_server_nomutex( conn, conn->c_connid, -1, err, syserr );
 					ret = CONN_DONE;
 					goto done;
 				}
 				slapi_log_err(SLAPI_LOG_CONNS,
-					   "connection_read_operation", "connection %" NSPRIu64 " waited %d times for read to be ready\n", conn->c_connid, waits_done);
+					   "connection_read_operation", "connection %" PRIu64 " waited %d times for read to be ready\n", conn->c_connid, waits_done);
 			} else {
 				/* Some other error, typically meaning bad stuff */
 					syserr = PR_GetOSError();
 					slapi_log_err(SLAPI_LOG_CONNS, "connection_read_operation",
-						"PR_Recv for connection %" NSPRIu64 " returns %d (%s)\n", conn->c_connid, err, slapd_pr_strerror( err ) );
+						"PR_Recv for connection %" PRIu64 " returns %d (%s)\n", conn->c_connid, err, slapd_pr_strerror( err ) );
 					/* If this happens we should close the connection */
 					disconnect_server_nomutex( conn, conn->c_connid, -1, err, syserr );
 					ret = CONN_DONE;
@@ -1286,7 +1286,7 @@ int connection_read_operation(Connection *conn, Operation *op, ber_tag_t *tag, i
 				}
 			}
 			slapi_log_err(SLAPI_LOG_CONNS,
-				   "connection_read_operation", "connection %" NSPRIu64 " read %d bytes\n", conn->c_connid, ret);
+				   "connection_read_operation", "connection %" PRIu64 " read %d bytes\n", conn->c_connid, ret);
 
 			new_operation = 0;
 			ret = CONN_FOUND_WORK_TO_DO;
@@ -1307,7 +1307,7 @@ int connection_read_operation(Connection *conn, Operation *op, ber_tag_t *tag, i
 		 * We received a non-LDAP message.  Log and close connection.
 		 */
 		slapi_log_err(SLAPI_LOG_ERR,
-			"connection_read_operation", "conn=%" NSPRIu64 " received a non-LDAP message (tag 0x%lx, expected 0x%lx)\n",
+			"connection_read_operation", "conn=%" PRIu64 " received a non-LDAP message (tag 0x%lx, expected 0x%lx)\n",
 			conn->c_connid, *tag, LDAP_TAG_MESSAGE );
 		disconnect_server_nomutex( conn, conn->c_connid, -1,
 			SLAPD_DISCONNECT_BAD_BER_TAG, EPROTO );
@@ -1319,7 +1319,7 @@ int connection_read_operation(Connection *conn, Operation *op, ber_tag_t *tag, i
 		!= LDAP_TAG_MSGID ) {
 		/* log, close and send error */
 		slapi_log_err(SLAPI_LOG_ERR,
-			"connection_read_operation", "conn=%" NSPRIu64 " unable to read tag for incoming request\n", conn->c_connid);
+			"connection_read_operation", "conn=%" PRIu64 " unable to read tag for incoming request\n", conn->c_connid);
 		disconnect_server_nomutex( conn, conn->c_connid, -1, SLAPD_DISCONNECT_BAD_BER_TAG, EPROTO );
 		ret = CONN_DONE;
 		goto done;
@@ -1337,7 +1337,7 @@ int connection_read_operation(Connection *conn, Operation *op, ber_tag_t *tag, i
 	  case LDAP_TAG_LDAPDN: /* optional username, for CLDAP */
 		/* log, close and send error */
 		slapi_log_err(SLAPI_LOG_ERR,
-			"connection_read_operation", "conn=%" NSPRIu64 " ber_peek_tag returns 0x%lx\n", conn->c_connid, *tag);
+			"connection_read_operation", "conn=%" PRIu64 " ber_peek_tag returns 0x%lx\n", conn->c_connid, *tag);
 		disconnect_server_nomutex( conn, conn->c_connid, -1, SLAPD_DISCONNECT_BER_PEEK, EPROTO );
 		ret = CONN_DONE;
 		goto done;
@@ -1361,7 +1361,7 @@ void connection_make_readable(Connection *conn)
 void connection_make_readable_nolock(Connection *conn)
 {
 	conn->c_gettingber = 0;
-	slapi_log_err(SLAPI_LOG_CONNS, "connection_make_readable_nolock", "making readable conn %" NSPRIu64 " fd=%d\n",
+	slapi_log_err(SLAPI_LOG_CONNS, "connection_make_readable_nolock", "making readable conn %" PRIu64 " fd=%d\n",
 		       conn->c_connid, conn->c_sd);
 	if (!(conn->c_flags & CONN_FLAG_CLOSING)) {
 		/* if the connection is closing, try the close in connection_release_nolock */
@@ -1388,7 +1388,7 @@ void connection_check_activity_level(Connection *conn)
 	/* update the last checked time */
 	conn->c_private->previous_count_check_time = current_time();
 	PR_ExitMonitor(conn->c_mutex);
-	slapi_log_err(SLAPI_LOG_CONNS,"connection_check_activity_level", "conn %" NSPRIu64 " activity level = %d\n",conn->c_connid,delta_count); 
+	slapi_log_err(SLAPI_LOG_CONNS,"connection_check_activity_level", "conn %" PRIu64 " activity level = %d\n",conn->c_connid,delta_count); 
 }
 
 typedef struct table_iterate_info_struct {
@@ -1450,7 +1450,7 @@ void connection_enter_leave_turbo(Connection *conn, int current_turbo_flag, int
 	  double activet = 0.0;
 	  connection_find_our_rank(conn,&connection_count, &our_rank);
 	  slapi_log_err(SLAPI_LOG_CONNS,"connection_enter_leave_turbo",
-	      "conn %" NSPRIu64 " turbo rank = %d out of %d conns\n",conn->c_connid,our_rank,connection_count); 
+	      "conn %" PRIu64 " turbo rank = %d out of %d conns\n",conn->c_connid,our_rank,connection_count); 
 	  activet = (double)g_get_active_threadcnt();
 	  threshold_rank = (int)(activet * ((double)CONN_TURBO_PERCENTILE / 100.0));
 
@@ -1491,9 +1491,9 @@ void connection_enter_leave_turbo(Connection *conn, int current_turbo_flag, int
 	PR_ExitMonitor(conn->c_mutex);
 	if (current_mode != new_mode) {
 		if (current_mode) {
-			slapi_log_err(SLAPI_LOG_CONNS,"connection_enter_leave_turbo", "conn %" NSPRIu64 " leaving turbo mode\n",conn->c_connid); 
+			slapi_log_err(SLAPI_LOG_CONNS,"connection_enter_leave_turbo", "conn %" PRIu64 " leaving turbo mode\n",conn->c_connid); 
 		} else {
-			slapi_log_err(SLAPI_LOG_CONNS,"connection_enter_leave_turbo", "conn %" NSPRIu64 " entering turbo mode\n",conn->c_connid); 
+			slapi_log_err(SLAPI_LOG_CONNS,"connection_enter_leave_turbo", "conn %" PRIu64 " entering turbo mode\n",conn->c_connid); 
 		}
 	}
 	*new_turbo_flag = new_mode;
@@ -1617,12 +1617,12 @@ connection_threadmain()
 		ret = connection_read_operation(conn, op, &tag, &more_data);
 		if ((ret == CONN_DONE) || (ret == CONN_TIMEDOUT)) {
 			slapi_log_err(SLAPI_LOG_CONNS, "connection_threadmain",
-					"conn %" NSPRIu64 " read not ready due to %d - thread_turbo_flag %d more_data %d "
+					"conn %" PRIu64 " read not ready due to %d - thread_turbo_flag %d more_data %d "
 					"ops_initiated %d refcnt %d flags %d\n", conn->c_connid, ret, thread_turbo_flag, more_data,
 					conn->c_opsinitiated, conn->c_refcnt, conn->c_flags);
 		} else if (ret == CONN_FOUND_WORK_TO_DO) {
 			slapi_log_err(SLAPI_LOG_CONNS, "connection_threadmain",
-					"conn %" NSPRIu64 " read operation successfully - thread_turbo_flag %d more_data %d "
+					"conn %" PRIu64 " read operation successfully - thread_turbo_flag %d more_data %d "
 					"ops_initiated %d refcnt %d flags %d\n", conn->c_connid, thread_turbo_flag, more_data,
 					conn->c_opsinitiated, conn->c_refcnt, conn->c_flags);
 		}
@@ -1648,7 +1648,7 @@ connection_threadmain()
 		if (thread_turbo_flag && !WORK_Q_EMPTY) {
 			thread_turbo_flag = 0;
 			slapi_log_err(SLAPI_LOG_CONNS,"connection_threadmain",
-				"conn %" NSPRIu64 " leaving turbo mode - pb_q is not empty %d\n",
+				"conn %" PRIu64 " leaving turbo mode - pb_q is not empty %d\n",
 			    conn->c_connid,work_q_size);
 		}
 #endif
@@ -1675,7 +1675,7 @@ connection_threadmain()
 				 * connection_make_readable(conn);
 				 */
 				slapi_log_err(SLAPI_LOG_CONNS,"connection_threadmain",
-					"conn %" NSPRIu64 " leaving turbo mode due to %d\n",
+					"conn %" PRIu64 " leaving turbo mode due to %d\n",
 					conn->c_connid,ret);
 				goto done;
 			case CONN_SHUTDOWN:
@@ -1732,7 +1732,7 @@ connection_threadmain()
 					 */
 					conn->c_idlesince = curtime;
 					connection_activity(conn, maxthreads);
-					slapi_log_err(SLAPI_LOG_CONNS,"connection_threadmain", "conn %" NSPRIu64 " queued because more_data\n",
+					slapi_log_err(SLAPI_LOG_CONNS,"connection_threadmain", "conn %" PRIu64 " queued because more_data\n",
 					          conn->c_connid);
 				} else {
 					/* keep count of how many times maxthreads has blocked an operation */
@@ -1814,7 +1814,7 @@ done:
 			/* If we're in turbo mode, we keep our reference to the connection alive */
 			/* can't use the more_data var because connection could have changed in another thread */
 			more_data = conn_buffered_data_avail_nolock(conn, &conn_closed) ? 1 : 0;
-			slapi_log_err(SLAPI_LOG_CONNS,"connection_threadmain", "conn %" NSPRIu64 " check more_data %d thread_turbo_flag %d\n",
+			slapi_log_err(SLAPI_LOG_CONNS,"connection_threadmain", "conn %" PRIu64 " check more_data %d thread_turbo_flag %d\n",
 			          conn->c_connid,more_data,thread_turbo_flag);
 			if (!more_data) {
 				if (!thread_turbo_flag) {
@@ -1863,7 +1863,7 @@ connection_activity(Connection *conn, int maxthreads)
 
 	if (connection_acquire_nolock (conn) == -1) {
 		slapi_log_err(SLAPI_LOG_CONNS,
-		          "connection_activity", "Could not acquire lock in connection_activity as conn %" NSPRIu64 " closing fd=%d\n",
+		          "connection_activity", "Could not acquire lock in connection_activity as conn %" PRIu64 " closing fd=%d\n",
 		          conn->c_connid,conn->c_sd);
 		/* XXX how to handle this error? */
 		/* MAB: 25 Jan 01: let's return on error and pray this won't leak */
@@ -2046,7 +2046,7 @@ connection_remove_operation( Connection *conn, Operation *op )
 
 	if ( *tmp == NULL )
 	{
-		slapi_log_err(SLAPI_LOG_ERR, "connection_remove_operation", "Can't find op %d for conn %" NSPRIu64 "\n",
+		slapi_log_err(SLAPI_LOG_ERR, "connection_remove_operation", "Can't find op %d for conn %" PRIu64 "\n",
 		    (int)op->o_msgid, conn->c_connid);
 	}
 	else
@@ -2187,13 +2187,13 @@ log_ber_too_big_error(const Connection *conn, ber_len_t ber_len,
 	}
 	if (0 == ber_len) {
 		slapi_log_err(SLAPI_LOG_ERR, "log_ber_too_big_error",
-			"conn=%" NSPRIu64 " fd=%d Incoming BER Element was too long, max allowable"
+			"conn=%" PRIu64 " fd=%d Incoming BER Element was too long, max allowable"
 			" is %" BERLEN_T " bytes. Change the nsslapd-maxbersize attribute in"
 			" cn=config to increase.\n",
 			conn->c_connid, conn->c_sd, maxbersize );
 	} else {
 		slapi_log_err(SLAPI_LOG_ERR, "log_ber_too_big_error",
-			"conn=%" NSPRIu64 " fd=%d Incoming BER Element was %" BERLEN_T " bytes, max allowable"
+			"conn=%" PRIu64 " fd=%d Incoming BER Element was %" BERLEN_T " bytes, max allowable"
 			" is %" BERLEN_T " bytes. Change the nsslapd-maxbersize attribute in"
 			" cn=config to increase.\n",
 			conn->c_connid, conn->c_sd, ber_len, maxbersize );
@@ -2224,7 +2224,7 @@ disconnect_server_nomutex_ext( Connection *conn, PRUint64 opconnid, int opid, PR
     if ( ( conn->c_sd != SLAPD_INVALID_SOCKET &&
 	    conn->c_connid == opconnid ) && !(conn->c_flags & CONN_FLAG_CLOSING) )
 	{
-		slapi_log_err(SLAPI_LOG_CONNS, "disconnect_server_nomutex_ext", "Setting conn %" NSPRIu64 " fd=%d "
+		slapi_log_err(SLAPI_LOG_CONNS, "disconnect_server_nomutex_ext", "Setting conn %" PRIu64 " fd=%d "
 			  "to be disconnected: reason %d\n", conn->c_connid, conn->c_sd, reason);
 		/*
 		 * PR_Close must be called before anything else is done because
@@ -2248,13 +2248,13 @@ disconnect_server_nomutex_ext( Connection *conn, PRUint64 opconnid, int opid, PR
 		 */
 		if (error && (EPIPE != error) ) {
 			slapi_log_access( LDAP_DEBUG_STATS,
-			  "conn=%" NSPRIu64 " op=%d fd=%d closed error %d (%s) - %s\n",
+			  "conn=%" PRIu64 " op=%d fd=%d closed error %d (%s) - %s\n",
 			  conn->c_connid, opid, conn->c_sd, error,
 			  slapd_system_strerror(error),
 			  slapd_pr_strerror(reason));
 		} else {
 			slapi_log_access( LDAP_DEBUG_STATS,
-			  "conn=%" NSPRIu64 " op=%d fd=%d closed - %s\n",
+			  "conn=%" PRIu64 " op=%d fd=%d closed - %s\n",
 			  conn->c_connid, opid, conn->c_sd,
 			  slapd_pr_strerror(reason));
 		}
diff --git a/ldap/servers/slapd/conntable.c b/ldap/servers/slapd/conntable.c
index bcafa4e..30da055 100644
--- a/ldap/servers/slapd/conntable.c
+++ b/ldap/servers/slapd/conntable.c
@@ -395,7 +395,7 @@ connection_table_as_entry(Connection_Table *ct, Slapi_Entry *e)
 			 * 3 = The number of operations attempted that were blocked
 			 *     by max threads.
 			 */
-			snprintf(maxthreadbuf, sizeof(maxthreadbuf), "%d:%"NSPRIu64":%"NSPRIu64"",
+			snprintf(maxthreadbuf, sizeof(maxthreadbuf), "%d:%"PRIu64":%"PRIu64"",
 				maxthreadstate, ct->c[i].c_maxthreadscount,
 				ct->c[i].c_maxthreadsblocked);
 
@@ -431,17 +431,17 @@ connection_table_as_entry(Connection_Table *ct, Slapi_Entry *e)
 	val.bv_len = strlen( buf );
 	attrlist_replace( &e->e_attrs, "currentconnections", vals );
 
-	snprintf( buf, sizeof(buf), "%" NSPRIu64, slapi_counter_get_value(num_conns));
+	snprintf( buf, sizeof(buf), "%" PRIu64, slapi_counter_get_value(num_conns));
 	val.bv_val = buf;
 	val.bv_len = strlen( buf );
 	attrlist_replace( &e->e_attrs, "totalconnections", vals );
 
-	snprintf( buf, sizeof(buf), "%" NSPRIu64, slapi_counter_get_value(conns_in_maxthreads));
+	snprintf( buf, sizeof(buf), "%" PRIu64, slapi_counter_get_value(conns_in_maxthreads));
 	val.bv_val = buf;
 	val.bv_len = strlen( buf );
 	attrlist_replace( &e->e_attrs, "currentconnectionsatmaxthreads", vals );
 
-	snprintf( buf, sizeof(buf), "%" NSPRIu64, slapi_counter_get_value(max_threads_count));
+	snprintf( buf, sizeof(buf), "%" PRIu64, slapi_counter_get_value(max_threads_count));
 	val.bv_val = buf;
 	val.bv_len = strlen( buf );
 	attrlist_replace( &e->e_attrs, "maxthreadsperconnhits", vals );
diff --git a/ldap/servers/slapd/control.c b/ldap/servers/slapd/control.c
index 8f9e74e..52f2519 100644
--- a/ldap/servers/slapd/control.c
+++ b/ldap/servers/slapd/control.c
@@ -335,7 +335,7 @@ get_ldapmessage_controls_ext(
                 slapi_pblock_set(pb, SLAPI_REQCONTROLS, NULL);
                 slapi_pblock_set(pb, SLAPI_MANAGEDSAIT, &ctrl_not_found);
                 slapi_pblock_set(pb, SLAPI_PWPOLICY, &ctrl_not_found);
-                slapi_log_err(SLAPI_LOG_CONNS, "get_ldapmessage_controls_ext", "Warning: conn=%" NSPRIu64 " op=%d contains an empty list of controls\n",
+                slapi_log_err(SLAPI_LOG_CONNS, "get_ldapmessage_controls_ext", "Warning: conn=%" PRIu64 " op=%d contains an empty list of controls\n",
                         pb->pb_conn->c_connid, pb->pb_op->o_opid);
         } else {
                 /* len, ber_len_t is uint, not int, cannot be != -1, may be better to remove this check.  */
diff --git a/ldap/servers/slapd/daemon.c b/ldap/servers/slapd/daemon.c
index a4ea4c0..5f2471e 100644
--- a/ldap/servers/slapd/daemon.c
+++ b/ldap/servers/slapd/daemon.c
@@ -616,7 +616,7 @@ disk_monitoring_thread(void *nothing)
          */
         if(disk_space < 4096){ /* 4 k */
             slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space is critically low on disk (%s), "
-            	"remaining space: %" NSPRIu64 " Kb.  Signaling slapd for shutdown...\n", dirstr , (disk_space / 1024));
+            	"remaining space: %" PRIu64 " Kb.  Signaling slapd for shutdown...\n", dirstr , (disk_space / 1024));
             g_set_shutdown( SLAPI_SHUTDOWN_EXIT );
             return;
         }
@@ -626,7 +626,7 @@ disk_monitoring_thread(void *nothing)
          */
         if(verbose_logging != 0 && verbose_logging != LDAP_DEBUG_ANY){
             slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space is low on disk (%s), remaining space: "
-            	"%" NSPRIu64 " Kb, temporarily setting error loglevel to the default level(%d).\n", dirstr,
+            	"%" PRIu64 " Kb, temporarily setting error loglevel to the default level(%d).\n", dirstr,
                 (disk_space / 1024), SLAPD_DEFAULT_ERRORLOG_LEVEL);
             /* Setting the log level back to zero, actually sets the value to LDAP_DEBUG_ANY */
             config_set_errorlog_level(CONFIG_LOGLEVEL_ATTRIBUTE,
@@ -640,7 +640,7 @@ disk_monitoring_thread(void *nothing)
          */
         if(!logs_disabled && !logging_critical){
             slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space is too low on disk (%s), remaining "
-            	"space: %" NSPRIu64 " Kb, disabling access and audit logging.\n", dirstr, (disk_space / 1024));
+            	"space: %" PRIu64 " Kb, disabling access and audit logging.\n", dirstr, (disk_space / 1024));
             config_set_accesslog_enabled(LOGGING_OFF);
             config_set_auditlog_enabled(LOGGING_OFF);
             config_set_auditfaillog_enabled(LOGGING_OFF);
@@ -653,7 +653,7 @@ disk_monitoring_thread(void *nothing)
          */
         if(!deleted_rotated_logs && !logging_critical){
             slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space is too low on disk (%s), remaining "
-            	"space: %" NSPRIu64 " Kb, deleting rotated logs.\n", dirstr, (disk_space / 1024));
+            	"space: %" PRIu64 " Kb, deleting rotated logs.\n", dirstr, (disk_space / 1024));
             log__delete_rotated_logs();
             deleted_rotated_logs = 1;
             continue;
@@ -663,7 +663,7 @@ disk_monitoring_thread(void *nothing)
          */
         if(disk_space < previous_mark){
             slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space is too low on disk (%s), remaining "
-            	"space: %" NSPRIu64 " Kb\n", dirstr, (disk_space / 1024));
+            	"space: %" PRIu64 " Kb\n", dirstr, (disk_space / 1024));
         }
         /*
          *
@@ -674,7 +674,7 @@ disk_monitoring_thread(void *nothing)
          *
          */
         if(disk_space < halfway){
-            slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space on (%s) is too far below the threshold(%" NSPRIu64 " bytes).  "
+            slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space on (%s) is too far below the threshold(%" PRIu64 " bytes).  "
                 "Waiting %d minutes for disk space to be cleaned up before shutting slapd down...\n",
                 dirstr, threshold, (grace_period / 60));
             time(&start);
@@ -697,7 +697,7 @@ disk_monitoring_thread(void *nothing)
                      *  Excellent, we are back to acceptable levels, reset everything...
                      */
                     slapi_log_err(SLAPI_LOG_INFO, "disk_monitoring_thread", "Available disk space is now "
-                    	"acceptable (%" NSPRIu64 " bytes).  Aborting shutdown, and restoring the log settings.\n",
+                    	"acceptable (%" PRIu64 " bytes).  Aborting shutdown, and restoring the log settings.\n",
                     	disk_space);
                     if(logs_disabled && using_accesslog){
                         config_set_accesslog_enabled(LOGGING_ON);
@@ -721,7 +721,7 @@ disk_monitoring_thread(void *nothing)
                      *  Disk space is critical, log an error, and shut it down now!
                      */
                     slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space is critically low "
-                    	"on disk (%s), remaining space: %" NSPRIu64 " Kb.  Signaling slapd for shutdown...\n", 
+                    	"on disk (%s), remaining space: %" PRIu64 " Kb.  Signaling slapd for shutdown...\n", 
                     	dirstr, (disk_space / 1024));
                     g_set_shutdown( SLAPI_SHUTDOWN_DISKFULL );
                     return;
@@ -739,7 +739,7 @@ disk_monitoring_thread(void *nothing)
              *  If disk space was freed up we would of detected in the above while loop.  So shut it down.
              */
             slapi_log_err(SLAPI_LOG_ALERT, "disk_monitoring_thread", "Disk space is still too low "
-            	"(%" NSPRIu64 " Kb).  Signaling slapd for shutdown...\n", (disk_space / 1024));
+            	"(%" PRIu64 " Kb).  Signaling slapd for shutdown...\n", (disk_space / 1024));
             g_set_shutdown( SLAPI_SHUTDOWN_DISKFULL );
 
             return;
@@ -1785,7 +1785,7 @@ handle_pr_read_ready(Connection_Table *ct, PRIntn num_poll)
 						 * trying to acquire a closing connection
 						 */
 						slapi_log_err(SLAPI_LOG_ERR,
-							"handle_pr_read_ready", "connection_activity: abandoning conn %" NSPRIu64 " as "
+							"handle_pr_read_ready", "connection_activity: abandoning conn %" PRIu64 " as "
 							"fd=%d is already closing\n", c->c_connid,c->c_sd);
 						/* The call disconnect_server should do nothing,
 						 * as the connection c should be already set to CLOSING */
@@ -1843,7 +1843,7 @@ ns_handle_closure(struct ns_job_t *job)
 #else
     /* This doesn't actually confirm it's in the event loop thread, but it's a start */
 	if (NS_JOB_IS_THREAD(ns_job_get_type(job)) != 0) {
-		slapi_log_err(SLAPI_LOG_ERR, "ns_handle_closure", "Attempt to close outside of event loop thread %" NSPRIu64 " for fd=%d\n",
+		slapi_log_err(SLAPI_LOG_ERR, "ns_handle_closure", "Attempt to close outside of event loop thread %" PRIu64 " for fd=%d\n",
 			c->c_connid, c->c_sd);
 		return;
 	}
@@ -1883,7 +1883,7 @@ ns_connection_post_io_or_closing(Connection *conn)
 		PR_ASSERT((conn->c_ns_close_jobs == 0) || (conn->c_ns_close_jobs == 1));
 		if (conn->c_ns_close_jobs) {
 			slapi_log_err(SLAPI_LOG_CONNS, "ns_connection_post_io_or_closing", "Already a close "
-				"job in progress on conn %" NSPRIu64 " for fd=%d\n", conn->c_connid, conn->c_sd);
+				"job in progress on conn %" PRIu64 " for fd=%d\n", conn->c_connid, conn->c_sd);
 			return;
 		} else {
 			/* just make sure we schedule the event to be closed in a timely manner */
@@ -1898,10 +1898,10 @@ ns_connection_post_io_or_closing(Connection *conn)
 #endif
 			if (job_result != PR_SUCCESS) {
 				slapi_log_err(SLAPI_LOG_WARNING, "ns_connection_post_io_or_closing", "post closure job "
-					"for conn %" NSPRIu64 " for fd=%d failed to be added to event queue\n", conn->c_connid, conn->c_sd);
+					"for conn %" PRIu64 " for fd=%d failed to be added to event queue\n", conn->c_connid, conn->c_sd);
 			} else {
 				slapi_log_err(SLAPI_LOG_CONNS, "ns_connection_post_io_or_closing", "post closure job "
-					"for conn %" NSPRIu64 " for fd=%d\n", conn->c_connid, conn->c_sd);
+					"for conn %" PRIu64 " for fd=%d\n", conn->c_connid, conn->c_sd);
 			}
 			
 		}
@@ -1938,10 +1938,10 @@ ns_connection_post_io_or_closing(Connection *conn)
 #endif
 		if (job_result != PR_SUCCESS) {
 			slapi_log_err(SLAPI_LOG_WARNING, "ns_connection_post_io_or_closing", "post I/O job for "
-				"conn %" NSPRIu64 " for fd=%d failed to be added to event queue\n", conn->c_connid, conn->c_sd);
+				"conn %" PRIu64 " for fd=%d failed to be added to event queue\n", conn->c_connid, conn->c_sd);
 		} else {
 			slapi_log_err(SLAPI_LOG_CONNS, "ns_connection_post_io_or_closing", "post I/O job for "
-				"conn %" NSPRIu64 " for fd=%d\n", conn->c_connid, conn->c_sd);
+				"conn %" PRIu64 " for fd=%d\n", conn->c_connid, conn->c_sd);
 		}
 	}
 #endif
@@ -1964,14 +1964,14 @@ ns_handle_pr_read_ready(struct ns_job_t *job)
 #else
     /* This doesn't actually confirm it's in the event loop thread, but it's a start */
 	if (NS_JOB_IS_THREAD(ns_job_get_type(job)) != 0) {
-		slapi_log_err(SLAPI_LOG_ERR, "ns_handle_pr_read_ready", "Attempt to handle read ready outside of event loop thread %" NSPRIu64 " for fd=%d\n",
+		slapi_log_err(SLAPI_LOG_ERR, "ns_handle_pr_read_ready", "Attempt to handle read ready outside of event loop thread %" PRIu64 " for fd=%d\n",
 			c->c_connid, c->c_sd);
 		return;
 	}
 #endif
 
 	PR_EnterMonitor(c->c_mutex);
-	slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "activity on conn %" NSPRIu64 " for fd=%d\n",
+	slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "activity on conn %" PRIu64 " for fd=%d\n",
 		       c->c_connid, c->c_sd);
 	/* if we were called due to some i/o event, see what the state of the socket is */
 	if (slapi_is_loglevel_set(SLAPI_LOG_CONNS) && !NS_JOB_IS_TIMER(ns_job_get_output_type(job)) && c && c->c_sd) {
@@ -1980,16 +1980,16 @@ ns_handle_pr_read_ready(struct ns_job_t *job)
 		ssize_t rc = recv(c->c_sd, buf, sizeof(buf), MSG_PEEK);
 		if (!rc) {
 			slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "socket is closed conn"
-				" %" NSPRIu64 " for fd=%d\n", c->c_connid, c->c_sd);
+				" %" PRIu64 " for fd=%d\n", c->c_connid, c->c_sd);
 		} else if (rc > 0) {
 			slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "socket read data available"
-				" for conn %" NSPRIu64 " for fd=%d\n", c->c_connid, c->c_sd);
+				" for conn %" PRIu64 " for fd=%d\n", c->c_connid, c->c_sd);
 		} else if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {
 			slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "socket has no data available"
-				" conn %" NSPRIu64 " for fd=%d\n", c->c_connid, c->c_sd);
+				" conn %" PRIu64 " for fd=%d\n", c->c_connid, c->c_sd);
 		} else {
 			slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "socket has error [%d] "
-				"conn %" NSPRIu64 " for fd=%d\n", errno, c->c_connid, c->c_sd);
+				"conn %" PRIu64 " for fd=%d\n", errno, c->c_connid, c->c_sd);
 		}
 	}
 	connection_release_nolock_ext(c, 1); /* release ref acquired when job was added */
@@ -2013,7 +2013,7 @@ ns_handle_pr_read_ready(struct ns_job_t *job)
 		 * trying to acquire a closing connection
 		 */
 		slapi_log_err(SLAPI_LOG_ERR, "ns_handle_pr_read_ready", "connection_activity: abandoning"
-			" conn %" NSPRIu64 " as fd=%d is already closing\n", c->c_connid, c->c_sd);
+			" conn %" PRIu64 " as fd=%d is already closing\n", c->c_connid, c->c_sd);
 		/* The call disconnect_server should do nothing,
 		 * as the connection c should be already set to CLOSING */
 		disconnect_server_nomutex_ext(c, c->c_connid, -1,
@@ -2021,7 +2021,7 @@ ns_handle_pr_read_ready(struct ns_job_t *job)
 				              0 /* do not schedule closure, do it next */);
 		ns_handle_closure_nomutex(c);
 	} else {
-		slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "queued conn %" NSPRIu64 " for fd=%d\n",
+		slapi_log_err(SLAPI_LOG_CONNS, "ns_handle_pr_read_ready", "queued conn %" PRIu64 " for fd=%d\n",
 			       c->c_connid, c->c_sd);
 	}
 	PR_ExitMonitor(c->c_mutex);
diff --git a/ldap/servers/slapd/delete.c b/ldap/servers/slapd/delete.c
index a16718a..e4e82a3 100644
--- a/ldap/servers/slapd/delete.c
+++ b/ldap/servers/slapd/delete.c
@@ -260,7 +260,7 @@ static void op_shared_delete (Slapi_PBlock *pb)
 
 		if (!internal_op )
 		{
-			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d DEL dn=\"%s\"%s\n",
+			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d DEL dn=\"%s\"%s\n",
 							pb->pb_conn->c_connid,
 							pb->pb_op->o_opid,
 							slapi_sdn_get_dn(sdn),
diff --git a/ldap/servers/slapd/entry.c b/ldap/servers/slapd/entry.c
index abacc57..b56e3da 100644
--- a/ldap/servers/slapd/entry.c
+++ b/ldap/servers/slapd/entry.c
@@ -3095,7 +3095,7 @@ slapi_entry_attr_set_ulong( Slapi_Entry* e, const char *type, uint64_t l)
 	struct berval *bvals[2];
 	bvals[0] = &bv;
 	bvals[1] = NULL;
-    sprintf(value,"%" NSPRIu64, l);
+    sprintf(value,"%" PRIu64, l);
 	bv.bv_val = value;
 	bv.bv_len = strlen( value );
     slapi_entry_attr_replace( e, type, bvals );
diff --git a/ldap/servers/slapd/extendop.c b/ldap/servers/slapd/extendop.c
index 7e41b8c..6a5d2e3 100644
--- a/ldap/servers/slapd/extendop.c
+++ b/ldap/servers/slapd/extendop.c
@@ -247,14 +247,14 @@ do_extended( Slapi_PBlock *pb )
     if ( NULL == ( name = extended_op_oid2string( extoid ))) {
         slapi_log_err(SLAPI_LOG_ARGS, "do_extended", "oid (%s)\n", extoid);
 
-        slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d EXT oid=\"%s\"\n",
+        slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d EXT oid=\"%s\"\n",
                 pb->pb_conn->c_connid, pb->pb_op->o_opid, extoid );
     } else {
         slapi_log_err(SLAPI_LOG_ARGS, "do_extended", "oid (%s-%s)\n",
                 extoid, name);
 
         slapi_log_access( LDAP_DEBUG_STATS,
-            "conn=%" NSPRIu64 " op=%d EXT oid=\"%s\" name=\"%s\"\n",
+            "conn=%" PRIu64 " op=%d EXT oid=\"%s\" name=\"%s\"\n",
             pb->pb_conn->c_connid, pb->pb_op->o_opid, extoid, name );
     }
 
diff --git a/ldap/servers/slapd/log.c b/ldap/servers/slapd/log.c
index afedd5b..a63c6a6 100644
--- a/ldap/servers/slapd/log.c
+++ b/ldap/servers/slapd/log.c
@@ -2769,7 +2769,7 @@ log__open_accesslogfile(int logfile_state, int locked)
 	while ( logp) {
 		log_convert_time (logp->l_ctime, tbuf, 1 /*short*/);
 		PR_snprintf(buffer, sizeof(buffer), "LOGINFO:%s%s.%s (%lu) (%"
-			NSPRI64 "d)\n", PREVLOGFILE, loginfo.log_access_file, tbuf, 
+			PRId64 "d)\n", PREVLOGFILE, loginfo.log_access_file, tbuf, 
 			logp->l_ctime, logp->l_size);
 		LOG_WRITE(fpinfo, buffer, strlen(buffer), 0);
 		logp = logp->l_next;
@@ -2907,7 +2907,7 @@ log_rotate:
 		if (type == LOG_SIZE_EXCEEDED) {
 			slapi_log_err(SLAPI_LOG_TRACE, "log__needrotation",
 				"LOGINFO:End of Log because size exceeded(Max:%" 
-				NSPRI64 "d bytes) (Is:%" NSPRI64 "d bytes)\n",
+				PRId64 "d bytes) (Is:%" PRId64 "d bytes)\n",
 				maxlogsize, f_size);
 		} else  if ( type == LOG_EXPIRED) {
 			slapi_log_err(SLAPI_LOG_TRACE, "log__needrotation",
@@ -4636,7 +4636,7 @@ log__open_errorlogfile(int logfile_state, int locked)
 	while (logp) {
 		log_convert_time (logp->l_ctime, tbuf, 1 /*short */);
 		PR_snprintf(buffer, sizeof(buffer), "LOGINFO:%s%s.%s (%lu) (%" 
-			NSPRI64 "d)\n", PREVLOGFILE, loginfo.log_error_file, tbuf,
+			PRId64 "d)\n", PREVLOGFILE, loginfo.log_error_file, tbuf,
 			logp->l_ctime, logp->l_size);
 		LOG_WRITE(fpinfo, buffer, strlen(buffer), 0);
 		logp = logp->l_next;
@@ -4763,7 +4763,7 @@ log__open_auditlogfile(int logfile_state, int locked)
 	while ( logp) {
 		log_convert_time (logp->l_ctime, tbuf, 1 /*short */);	
 		PR_snprintf(buffer, sizeof(buffer), "LOGINFO:%s%s.%s (%lu) (%"
-			NSPRI64 "d)\n", PREVLOGFILE, loginfo.log_audit_file, tbuf, 
+			PRId64 "d)\n", PREVLOGFILE, loginfo.log_audit_file, tbuf, 
 			logp->l_ctime, logp->l_size);
 		LOG_WRITE(fpinfo, buffer, strlen(buffer), 0);
 		logp = logp->l_next;
@@ -4889,7 +4889,7 @@ log__open_auditfaillogfile(int logfile_state, int locked)
     while ( logp) {
         log_convert_time (logp->l_ctime, tbuf, 1 /*short */);   
         PR_snprintf(buffer, sizeof(buffer), "LOGINFO:%s%s.%s (%lu) (%"
-            NSPRI64 "d)\n", PREVLOGFILE, loginfo.log_auditfail_file, tbuf, 
+            PRId64 "d)\n", PREVLOGFILE, loginfo.log_auditfail_file, tbuf, 
             logp->l_ctime, logp->l_size);
         LOG_WRITE(fpinfo, buffer, strlen(buffer), 0);
         logp = logp->l_next;
diff --git a/ldap/servers/slapd/modify.c b/ldap/servers/slapd/modify.c
index e23fe67..da66b44 100644
--- a/ldap/servers/slapd/modify.c
+++ b/ldap/servers/slapd/modify.c
@@ -680,7 +680,7 @@ static void op_shared_modify (Slapi_PBlock *pb, int pw_change, char *old_pw)
 
 		if ( !internal_op )
 		{
-			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d MOD dn=\"%s\"%s\n",
+			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d MOD dn=\"%s\"%s\n",
 							 pb->pb_conn->c_connid,
 							 pb->pb_op->o_opid,
 							 slapi_sdn_get_dn(sdn),
@@ -1227,7 +1227,7 @@ static int op_shared_allow_pw_change (Slapi_PBlock *pb, LDAPMod *mod, char **old
 	{
 		if (operation_is_flag_set(operation,OP_FLAG_ACTION_LOG_ACCESS))
 		{
-			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d MOD dn=\"%s\"\n",
+			slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d MOD dn=\"%s\"\n",
 					pb->pb_conn->c_connid, pb->pb_op->o_opid,
 					slapi_sdn_get_dn(&sdn));
 		}
@@ -1267,7 +1267,7 @@ static int op_shared_allow_pw_change (Slapi_PBlock *pb, LDAPMod *mod, char **old
 				if (proxydn){
 					proxystr = slapi_ch_smprintf(" authzid=\"%s\"", proxydn);
 				}
-				slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d MOD dn=\"%s\"%s\n",
+				slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d MOD dn=\"%s\"%s\n",
 						pb->pb_conn->c_connid, pb->pb_op->o_opid,
 						slapi_sdn_get_dn(&sdn), proxystr ? proxystr : "");
 			}
@@ -1312,7 +1312,7 @@ static int op_shared_allow_pw_change (Slapi_PBlock *pb, LDAPMod *mod, char **old
 					proxystr = slapi_ch_smprintf(" authzid=\"%s\"", proxydn);
 				}
 
-				slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d MOD dn=\"%s\"%s, %s\n",
+				slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d MOD dn=\"%s\"%s, %s\n",
 						pb->pb_conn->c_connid, pb->pb_op->o_opid,
 						slapi_sdn_get_dn(&sdn),
 						proxystr ? proxystr : "",
@@ -1338,7 +1338,7 @@ static int op_shared_allow_pw_change (Slapi_PBlock *pb, LDAPMod *mod, char **old
 
 			if ( !internal_op )
 			{
-				slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d MOD dn=\"%s\"%s, %s\n",
+				slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d MOD dn=\"%s\"%s, %s\n",
 								 pb->pb_conn->c_connid,
 								 pb->pb_op->o_opid,
 								 slapi_sdn_get_dn(&sdn),
@@ -1381,7 +1381,7 @@ static int op_shared_allow_pw_change (Slapi_PBlock *pb, LDAPMod *mod, char **old
 
 					if ( !internal_op )
 					{
-						slapi_log_access(LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d MOD dn=\"%s\"%s, %s\n",
+						slapi_log_access(LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d MOD dn=\"%s\"%s, %s\n",
 										 pb->pb_conn->c_connid,
 										 pb->pb_op->o_opid,
 										 slapi_sdn_get_dn(&sdn),
diff --git a/ldap/servers/slapd/modrdn.c b/ldap/servers/slapd/modrdn.c
index 15f5210..69cca40 100644
--- a/ldap/servers/slapd/modrdn.c
+++ b/ldap/servers/slapd/modrdn.c
@@ -463,7 +463,7 @@ op_shared_rename(Slapi_PBlock *pb, int passin_args)
 		if ( !internal_op )
 		{
 			slapi_log_access(LDAP_DEBUG_STATS,
-					 "conn=%" NSPRIu64 " op=%d MODRDN dn=\"%s\" newrdn=\"%s\" newsuperior=\"%s\"%s\n",
+					 "conn=%" PRIu64 " op=%d MODRDN dn=\"%s\" newrdn=\"%s\" newsuperior=\"%s\"%s\n",
 					 pb->pb_conn->c_connid,
 					 pb->pb_op->o_opid,
 					 dn,
@@ -497,7 +497,7 @@ op_shared_rename(Slapi_PBlock *pb, int passin_args)
 	{
 		if ( !internal_op ) {
 			slapi_log_err(SLAPI_LOG_ARGS, "op_shared_rename", 
-				 "conn=%" NSPRIu64 " op=%d MODRDN invalid new RDN (\"%s\")\n",
+				 "conn=%" PRIu64 " op=%d MODRDN invalid new RDN (\"%s\")\n",
 				 pb->pb_conn->c_connid,
 				 pb->pb_op->o_opid,
 				 (NULL == newrdn) ? "(null)" : newrdn);
@@ -531,7 +531,7 @@ op_shared_rename(Slapi_PBlock *pb, int passin_args)
 			"Syntax check of newSuperior failed\n");
 		if (!internal_op) {
 			slapi_log_err(SLAPI_LOG_ARGS, "op_shared_rename",
-				 "conn=%" NSPRIu64 " op=%d MODRDN invalid new superior (\"%s\")",
+				 "conn=%" PRIu64 " op=%d MODRDN invalid new superior (\"%s\")",
 				 pb->pb_conn->c_connid,
 				 pb->pb_op->o_opid,
 				 newsuperior ? newsuperior : "(null)");
diff --git a/ldap/servers/slapd/monitor.c b/ldap/servers/slapd/monitor.c
index f1fb38f..8d1788f 100644
--- a/ldap/servers/slapd/monitor.c
+++ b/ldap/servers/slapd/monitor.c
@@ -60,19 +60,19 @@ monitor_info(Slapi_PBlock *pb, Slapi_Entry* e, Slapi_Entry* entryAfter, int *ret
 
 	connection_table_as_entry(the_connection_table, e);
 
-	val.bv_len = snprintf( buf, sizeof(buf), "%" NSPRIu64, slapi_counter_get_value(ops_initiated) );
+	val.bv_len = snprintf( buf, sizeof(buf), "%" PRIu64, slapi_counter_get_value(ops_initiated) );
 	val.bv_val = buf;
 	attrlist_replace( &e->e_attrs, "opsinitiated", vals );
 
-	val.bv_len = snprintf( buf, sizeof(buf), "%" NSPRIu64, slapi_counter_get_value(ops_completed) );
+	val.bv_len = snprintf( buf, sizeof(buf), "%" PRIu64, slapi_counter_get_value(ops_completed) );
 	val.bv_val = buf;
 	attrlist_replace( &e->e_attrs, "opscompleted", vals );
 
-	val.bv_len = snprintf ( buf, sizeof(buf), "%" NSPRIu64, g_get_num_entries_sent() );
+	val.bv_len = snprintf ( buf, sizeof(buf), "%" PRIu64, g_get_num_entries_sent() );
 	val.bv_val = buf;
 	attrlist_replace( &e->e_attrs, "entriessent", vals );
 
-	val.bv_len = snprintf ( buf, sizeof(buf), "%" NSPRIu64, g_get_num_bytes_sent() );
+	val.bv_len = snprintf ( buf, sizeof(buf), "%" PRIu64, g_get_num_bytes_sent() );
 	val.bv_val = buf;
 	attrlist_replace( &e->e_attrs, "bytessent", vals );
 
diff --git a/ldap/servers/slapd/operation.c b/ldap/servers/slapd/operation.c
index ccbc549..00fb9b8 100644
--- a/ldap/servers/slapd/operation.c
+++ b/ldap/servers/slapd/operation.c
@@ -580,7 +580,7 @@ int slapi_connection_acquire(Slapi_Connection *conn)
     {
 	/* This may happen while other threads are still working on this connection */
         slapi_log_err(SLAPI_LOG_ERR, "slapi_connection_acquire",
-		                "conn=%" NSPRIu64 " fd=%d Attempt to acquire connection in the closing state\n",
+		                "conn=%" PRIu64 " fd=%d Attempt to acquire connection in the closing state\n",
 		                conn->c_connid, conn->c_sd);
         rc = -1;
     }
@@ -606,7 +606,7 @@ slapi_connection_remove_operation( Slapi_PBlock *pb, Slapi_Connection *conn, Sla
 	if ( *tmp == NULL ) {
 		if (op) {
 			slapi_log_err(SLAPI_LOG_ERR, "slapi_connection_remove_operation",
-				"Can't find op %d for conn %" NSPRIu64 "\n",
+				"Can't find op %d for conn %" PRIu64 "\n",
 			    (int)op->o_msgid, conn->c_connid);
 		} else {
 			slapi_log_err(SLAPI_LOG_ERR, "slapi_connection_remove_operation",
@@ -620,7 +620,7 @@ slapi_connection_remove_operation( Slapi_PBlock *pb, Slapi_Connection *conn, Sla
 		/* connection_release_nolock(conn); */
 		if (conn->c_refcnt <= 0) {
 			slapi_log_err(SLAPI_LOG_ERR, "slapi_connection_remove_operation",
-			                "conn=%" NSPRIu64 " fd=%d Attempt to release connection that is not acquired\n",
+			                "conn=%" PRIu64 " fd=%d Attempt to release connection that is not acquired\n",
 			                conn->c_connid, conn->c_sd);
 			rc = -1;
 		} else {
diff --git a/ldap/servers/slapd/opshared.c b/ldap/servers/slapd/opshared.c
index 3ce7970..4682a73 100644
--- a/ldap/servers/slapd/opshared.c
+++ b/ldap/servers/slapd/opshared.c
@@ -289,7 +289,7 @@ op_shared_search (Slapi_PBlock *pb, int send_result)
   {
       char *fmtstr;
         
-#define SLAPD_SEARCH_FMTSTR_BASE "conn=%" NSPRIu64 " op=%d SRCH base=\"%s\" scope=%d "
+#define SLAPD_SEARCH_FMTSTR_BASE "conn=%" PRIu64 " op=%d SRCH base=\"%s\" scope=%d "
 #define SLAPD_SEARCH_FMTSTR_BASE_INT "conn=%s op=%d SRCH base=\"%s\" scope=%d "
 #define SLAPD_SEARCH_FMTSTR_REMAINDER " attrs=%s%s%s\n"
 
@@ -1744,7 +1744,7 @@ void op_shared_log_error_access (Slapi_PBlock *pb, const char *type, const char
         proxystr = slapi_ch_smprintf(" authzid=\"%s\"", proxydn);
     }
 
-    slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d %s dn=\"%s\"%s, %s\n",
+    slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d %s dn=\"%s\"%s, %s\n",
                       ( pb->pb_conn ? pb->pb_conn->c_connid : 0),
                       ( pb->pb_op ? pb->pb_op->o_opid : 0), 
                       type, 
diff --git a/ldap/servers/slapd/pagedresults.c b/ldap/servers/slapd/pagedresults.c
index a30e2fa..e8c80e7 100644
--- a/ldap/servers/slapd/pagedresults.c
+++ b/ldap/servers/slapd/pagedresults.c
@@ -310,7 +310,7 @@ pagedresults_free_one( Connection *conn, Operation *op, int index )
         PR_EnterMonitor(conn->c_mutex);
         if (conn->c_pagedresults.prl_count <= 0) {
             slapi_log_err(SLAPI_LOG_TRACE, "pagedresults_free_one",
-                           "conn=%" NSPRIu64 " paged requests list count is %d\n",
+                           "conn=%" PRIu64 " paged requests list count is %d\n",
                            conn->c_connid, conn->c_pagedresults.prl_count);
         } else if (index < conn->c_pagedresults.prl_maxlen) {
             PagedResults *prp = conn->c_pagedresults.prl_list + index;
diff --git a/ldap/servers/slapd/psearch.c b/ldap/servers/slapd/psearch.c
index 793bea3..2d0badc 100644
--- a/ldap/servers/slapd/psearch.c
+++ b/ldap/servers/slapd/psearch.c
@@ -283,7 +283,7 @@ ps_send_results( void *arg )
 
 	if (conn_acq_flag) {
 		slapi_log_err(SLAPI_LOG_CONNS, "ps_send_results",
-				"conn=%" NSPRIu64 " op=%d Could not acquire the connection - psearch aborted\n",
+				"conn=%" PRIu64 " op=%d Could not acquire the connection - psearch aborted\n",
 				ps->ps_pblock->pb_conn->c_connid, ps->ps_pblock->pb_op->o_opid);
 	}
 
@@ -293,7 +293,7 @@ ps_send_results( void *arg )
 	/* Check for an abandoned operation */
 	if ( ps->ps_pblock->pb_op == NULL || slapi_op_abandoned( ps->ps_pblock ) ) {
 		slapi_log_err(SLAPI_LOG_CONNS, "ps_send_results",
-				"conn=%" NSPRIu64 " op=%d The operation has been abandoned\n",
+				"conn=%" PRIu64 " op=%d The operation has been abandoned\n",
 				ps->ps_pblock->pb_conn->c_connid, ps->ps_pblock->pb_op->o_opid);
 	    break;
 	}
@@ -351,7 +351,7 @@ ps_send_results( void *arg )
 										 ectrls, attrs, attrsonly );
 			if (rc) {
 				slapi_log_err(SLAPI_LOG_CONNS, "ps_send_results",
-								"conn=%" NSPRIu64 " op=%d Error %d sending entry %s with op status %d\n",
+								"conn=%" PRIu64 " op=%d Error %d sending entry %s with op status %d\n",
 								ps->ps_pblock->pb_conn->c_connid, ps->ps_pblock->pb_op->o_opid,
 								rc, slapi_entry_get_dn_const(ec), ps->ps_pblock->pb_op->o_status);
 			}
@@ -400,7 +400,7 @@ ps_send_results( void *arg )
     PR_EnterMonitor(conn->c_mutex);
 
 	slapi_log_err(SLAPI_LOG_CONNS, "ps_send_results",
-					"conn=%" NSPRIu64 " op=%d Releasing the connection and operation\n",
+					"conn=%" PRIu64 " op=%d Releasing the connection and operation\n",
 					conn->c_connid, ps->ps_pblock->pb_op->o_opid);
     /* Delete this op from the connection's list */
     connection_remove_operation_ext( ps->ps_pblock, conn, ps->ps_pblock->pb_op );
@@ -535,7 +535,7 @@ ps_service_persistent_searches( Slapi_Entry *e, Slapi_Entry *eprev, ber_int_t ch
 		}
 
 		slapi_log_err(SLAPI_LOG_CONNS, "ps_service_persistent_searches",
-						"conn=%" NSPRIu64 " op=%d entry %s with chgtype %d "
+						"conn=%" PRIu64 " op=%d entry %s with chgtype %d "
 						"matches the ps changetype %d\n",
 						ps->ps_pblock->pb_conn->c_connid,
 						ps->ps_pblock->pb_op->o_opid,
diff --git a/ldap/servers/slapd/result.c b/ldap/servers/slapd/result.c
index 5c38bae..56257c3 100644
--- a/ldap/servers/slapd/result.c
+++ b/ldap/servers/slapd/result.c
@@ -1980,7 +1980,7 @@ log_result( Slapi_PBlock *pb, Operation *op, int err, ber_tag_t tag, int nentrie
 		if ( !internal_op )
 		{
 			slapi_log_access( LDAP_DEBUG_STATS,
-							  "conn=%" NSPRIu64 " op=%d RESULT err=%d"
+							  "conn=%" PRIu64 " op=%d RESULT err=%d"
 							  " tag=%" BERTAG_T " nentries=%d etime=%s%s%s"
 							  ", SASL bind in progress\n",
 							  op->o_connid,
@@ -2012,7 +2012,7 @@ log_result( Slapi_PBlock *pb, Operation *op, int err, ber_tag_t tag, int nentrie
 		if ( !internal_op )
 		{
 			slapi_log_access( LDAP_DEBUG_STATS,
-							  "conn=%" NSPRIu64 " op=%d RESULT err=%d"
+							  "conn=%" PRIu64 " op=%d RESULT err=%d"
 							  " tag=%" BERTAG_T " nentries=%d etime=%s%s%s"
 							  " dn=\"%s\"\n",
 							  op->o_connid,
@@ -2040,7 +2040,7 @@ log_result( Slapi_PBlock *pb, Operation *op, int err, ber_tag_t tag, int nentrie
 			if ( !internal_op )
 			{
 				slapi_log_access( LDAP_DEBUG_STATS,
-								  "conn=%" NSPRIu64 " op=%d RESULT err=%d"
+								  "conn=%" PRIu64 " op=%d RESULT err=%d"
 								  " tag=%" BERTAG_T " nentries=%d etime=%s%s%s"
 								  " pr_idx=%d pr_cookie=%d\n",
 								  op->o_connid, 
@@ -2073,7 +2073,7 @@ log_result( Slapi_PBlock *pb, Operation *op, int err, ber_tag_t tag, int nentrie
 				ext_str = "";
 			}
 			slapi_log_access( LDAP_DEBUG_STATS,
-							  "conn=%" NSPRIu64 " op=%d RESULT err=%d"
+							  "conn=%" PRIu64 " op=%d RESULT err=%d"
 							  " tag=%" BERTAG_T " nentries=%d etime=%s%s%s%s\n",
 							  op->o_connid,
 							  op->o_opid,
@@ -2142,7 +2142,7 @@ log_entry( Operation *op, Slapi_Entry *e )
 
 	if ( !internal_op )
 	{
-		slapi_log_access( LDAP_DEBUG_STATS2, "conn=%" NSPRIu64 " op=%d ENTRY dn=\"%s\"\n",
+		slapi_log_access( LDAP_DEBUG_STATS2, "conn=%" PRIu64 " op=%d ENTRY dn=\"%s\"\n",
 			op->o_connid, op->o_opid,
 			slapi_entry_get_dn_const(e));
 	}
@@ -2167,7 +2167,7 @@ log_referral( Operation *op )
 
 	if ( !internal_op )
 	{
-		slapi_log_access( LDAP_DEBUG_STATS2, "conn=%" NSPRIu64 " op=%d REFERRAL\n",
+		slapi_log_access( LDAP_DEBUG_STATS2, "conn=%" PRIu64 " op=%d REFERRAL\n",
 			op->o_connid, op->o_opid );
 	}
 	else
diff --git a/ldap/servers/slapd/sasl_io.c b/ldap/servers/slapd/sasl_io.c
index 1337e1c..9458083 100644
--- a/ldap/servers/slapd/sasl_io.c
+++ b/ldap/servers/slapd/sasl_io.c
@@ -198,17 +198,17 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
     /* first we need the length bytes */
     ret = PR_Recv(fd->lower, buffer, amount, flags, timeout);
     slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet",
-            "Read sasl packet length returned %d on connection %" NSPRIu64 "\n",
+            "Read sasl packet length returned %d on connection %" PRIu64 "\n",
             ret, c->c_connid);
     if (ret <= 0) {
         *err = PR_GetError();
         if (ret == 0) {
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet",
-                    "Connection closed while reading sasl packet length on connection %" NSPRIu64 "\n",
+                    "Connection closed while reading sasl packet length on connection %" PRIu64 "\n",
                     c->c_connid );
         } else {
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet",
-                    "Error reading sasl packet length on connection %" NSPRIu64 " %d:%s\n",
+                    "Error reading sasl packet length on connection %" PRIu64 " %d:%s\n",
                     c->c_connid, *err, slapd_pr_strerror(*err) );
         }
         return ret;
@@ -226,7 +226,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
     if (sp->encrypted_buffer_offset < sizeof(buffer)) {
         slapi_log_err(SLAPI_LOG_CONNS,
                "sasl_io_start_packet", "Read only %d bytes of sasl packet "
-               "length on connection %" NSPRIu64 "\n", ret, c->c_connid );
+               "length on connection %" PRIu64 "\n", ret, c->c_connid );
 #if defined(EWOULDBLOCK)
         errno = EWOULDBLOCK;
 #elif defined(EAGAIN)
@@ -251,7 +251,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
         ber_len_t ber_len = 0;
         ber_tag_t tag = 0;
 
-        slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" NSPRIu64 " fd=%d "
+        slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" PRIu64 " fd=%d "
                 "Sent an LDAP message that was not encrypted.\n", c->c_connid,
                 c->c_sd);
 
@@ -265,7 +265,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
         /* Is the ldap operation too large? */
         if(ber_len > maxbersize){
             slapi_log_err(SLAPI_LOG_ERR, "sasl_io_start_packet",
-                    "conn=%" NSPRIu64 " fd=%d Incoming BER Element was too long, max allowable "
+                    "conn=%" PRIu64 " fd=%d Incoming BER Element was too long, max allowable "
                     "is %" BERLEN_T " bytes. Change the nsslapd-maxbersize attribute in "
                     "cn=config to increase.\n",
                     c->c_connid, c->c_sd, maxbersize );
@@ -305,7 +305,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
             } else if (ret > 0) {
                 slapi_log_err(SLAPI_LOG_CONNS,
                         "sasl_io_start_packet",
-                        "Continued: read sasl packet length returned %d on connection %" NSPRIu64 "\n",
+                        "Continued: read sasl packet length returned %d on connection %" PRIu64 "\n",
                         ret, c->c_connid);
                 if((ret + sp->encrypted_buffer_offset) > sp->encrypted_buffer_size){
                 	sasl_io_resize_encrypted_buffer(sp, ret + sp->encrypted_buffer_offset);
@@ -316,7 +316,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
                 *err = PR_GetError();
                 slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet",
                 		"Error reading sasl packet length on connection "
-                        "%" NSPRIu64 " %d:%s\n", c->c_connid, *err, slapd_pr_strerror(*err) );
+                        "%" PRIu64 " %d:%s\n", c->c_connid, *err, slapd_pr_strerror(*err) );
                 return ret;
             }
         }
@@ -360,7 +360,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
                 tag = *ber->ber_ptr++;
                 if (*ber->ber_ptr == LDAP_REQ_UNBIND){
 #endif
-                    slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" NSPRIu64 " fd=%d "
+                    slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" PRIu64 " fd=%d "
                             "Received unencrypted UNBIND operation.\n", c->c_connid,
                             c->c_sd);
                     sp->encrypted_buffer_count = sp->encrypted_buffer_offset;
@@ -368,7 +368,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
                     ber_free(ber, 1);
                     return SASL_IO_BUFFER_NOT_ENCRYPTED;
                 }
-                slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" NSPRIu64 " fd=%d "
+                slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" PRIu64 " fd=%d "
                         "Error: received an LDAP message (tag 0x%lx) that was not encrypted.\n",
 #ifdef USE_OPENLDAP
                         c->c_connid, c->c_sd, (long unsigned int)tag);
@@ -380,7 +380,7 @@ sasl_io_start_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt
 
 done:
         /* If we got here we have garbage, or a denied LDAP operation */
-        slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" NSPRIu64 " fd=%d "
+        slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet", "conn=%" PRIu64 " fd=%d "
                 "Error: received an invalid message that was not encrypted.\n",
                 c->c_connid, c->c_sd);
 
@@ -399,7 +399,7 @@ done:
     packet_length += sizeof(uint32_t);
 
     slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_start_packet",
-                    "read sasl packet length %ld on connection %" NSPRIu64 "\n", 
+                    "read sasl packet length %ld on connection %" PRIu64 "\n", 
                     packet_length, c->c_connid );
 
     /* Check if the packet length is larger than our max allowed.  A
@@ -432,17 +432,17 @@ sasl_io_read_packet(PRFileDesc *fd, PRIntn flags, PRIntervalTime timeout, PRInt3
     size_t bytes_remaining_to_read = sp->encrypted_buffer_count - sp->encrypted_buffer_offset;
 
     slapi_log_err(SLAPI_LOG_CONNS,
-               "sasl_io_read_packet", "Reading %lu bytes for connection %" NSPRIu64 "\n",
+               "sasl_io_read_packet", "Reading %lu bytes for connection %" PRIu64 "\n",
                bytes_remaining_to_read, c->c_connid );
     ret = PR_Recv(fd->lower, sp->encrypted_buffer + sp->encrypted_buffer_offset, bytes_remaining_to_read, flags, timeout);
     if (ret <= 0) {
         *err = PR_GetError();
         if (ret == 0) {
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_read_packet",
-                    "Connection closed while reading sasl packet on connection %" NSPRIu64 "\n", c->c_connid );
+                    "Connection closed while reading sasl packet on connection %" PRIu64 "\n", c->c_connid );
         } else {
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_read_packet",
-                    "Error reading sasl packet on connection %" NSPRIu64 " %d:%s\n",
+                    "Error reading sasl packet on connection %" PRIu64 " %d:%s\n",
                     c->c_connid, *err, slapd_pr_strerror(*err) );
         }
         return ret;
@@ -464,10 +464,10 @@ sasl_io_recv(PRFileDesc *fd, void *buf, PRInt32 len, PRIntn flags,
     /* Do we have decrypted data buffered from 'before' ? */
     bytes_in_buffer = sp->decrypted_buffer_count - sp->decrypted_buffer_offset;
     slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_recv",
-            "Connection %" NSPRIu64 " len %d bytes_in_buffer %lu\n",
+            "Connection %" PRIu64 " len %d bytes_in_buffer %lu\n",
             c->c_connid, len, bytes_in_buffer );
     slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_recv",
-            "Connection %" NSPRIu64 " len %d encrypted buffer count %lu\n",
+            "Connection %" PRIu64 " len %d encrypted buffer count %lu\n",
             c->c_connid, len, sp->encrypted_buffer_count );
     if (0 == bytes_in_buffer) {
         /* If there wasn't buffered decrypted data, we need to get some... */
@@ -502,7 +502,7 @@ sasl_io_recv(PRFileDesc *fd, void *buf, PRInt32 len, PRIntn flags,
          */
         if (!sasl_io_finished_packet(sp)) {
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_recv",
-                    "Connection %" NSPRIu64 " - not finished reading packet yet\n", c->c_connid);
+                    "Connection %" PRIu64 " - not finished reading packet yet\n", c->c_connid);
 #if defined(EWOULDBLOCK)
             errno = EWOULDBLOCK;
 #elif defined(EAGAIN)
@@ -516,7 +516,7 @@ sasl_io_recv(PRFileDesc *fd, void *buf, PRInt32 len, PRIntn flags,
             const char *output_buffer = NULL;
             unsigned int output_length = 0;
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_recv",
-                    "Finished reading packet for connection %" NSPRIu64 "\n", c->c_connid );
+                    "Finished reading packet for connection %" PRIu64 "\n", c->c_connid );
             /* Now decode it */
             ret = sasl_decode(c->c_sasl_conn,sp->encrypted_buffer,sp->encrypted_buffer_count,&output_buffer,&output_length);
             /* even if decode fails, need re-initialize the encrypted_buffer */
@@ -524,7 +524,7 @@ sasl_io_recv(PRFileDesc *fd, void *buf, PRInt32 len, PRIntn flags,
             sp->encrypted_buffer_count = 0;
             if (SASL_OK == ret) {
                 slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_recv",
-                        "Decoded packet length %u for connection %" NSPRIu64 "\n", output_length, c->c_connid );
+                        "Decoded packet length %u for connection %" PRIu64 "\n", output_length, c->c_connid );
                 if (output_length) {
                     sasl_io_resize_decrypted_buffer(sp,output_length);
                     memcpy(sp->decrypted_buffer,output_buffer,output_length);
@@ -534,7 +534,7 @@ sasl_io_recv(PRFileDesc *fd, void *buf, PRInt32 len, PRIntn flags,
                 }
             } else {
                 slapi_log_err(SLAPI_LOG_ERR, "sasl_io_recv",
-                        "Failed to decode packet for connection %" NSPRIu64 "\n", c->c_connid );
+                        "Failed to decode packet for connection %" PRIu64 "\n", c->c_connid );
                 PR_SetError(PR_IO_ERROR, 0);
                 return PR_FAILURE;
             }
@@ -552,11 +552,11 @@ sasl_io_recv(PRFileDesc *fd, void *buf, PRInt32 len, PRIntn flags,
             sp->decrypted_buffer_offset = 0;
             sp->decrypted_buffer_count = 0;
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_recv",
-                    "All decrypted data returned for connection %" NSPRIu64 "\n", c->c_connid );
+                    "All decrypted data returned for connection %" PRIu64 "\n", c->c_connid );
         } else {
             sp->decrypted_buffer_offset += bytes_to_return;
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_recv",
-                    "Returning %lu bytes to caller %lu bytes left to return for connection %" NSPRIu64 "\n",
+                    "Returning %lu bytes to caller %lu bytes left to return for connection %" PRIu64 "\n",
                     bytes_to_return, sp->decrypted_buffer_count - sp->decrypted_buffer_offset, c->c_connid );
         }
         ret = bytes_to_return;
@@ -772,11 +772,11 @@ sasl_io_enable(Connection *c, void *data /* UNUSED */)
         rv = PR_PushIOLayer(c->c_prfd, PR_TOP_IO_LAYER, layer);
         if (rv) {
             slapi_log_err(SLAPI_LOG_ERR, "sasl_io_enable",
-                    "Error enabling sasl io on connection %" NSPRIu64 " %d:%s\n",
+                    "Error enabling sasl io on connection %" PRIu64 " %d:%s\n",
                     c->c_connid, rv, slapd_pr_strerror(rv) );
         } else {
             slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_enable",
-                    "Enabled sasl io on connection %" NSPRIu64 " \n", c->c_connid);
+                    "Enabled sasl io on connection %" PRIu64 " \n", c->c_connid);
             debug_print_layers(c->c_prfd);
         }
     }
@@ -794,7 +794,7 @@ sasl_io_cleanup(Connection *c, void *data /* UNUSED */)
     int ret = 0;
 
     slapi_log_err(SLAPI_LOG_CONNS, "sasl_io_cleanup",
-            "Connection %" NSPRIu64 "\n", c->c_connid);
+            "Connection %" PRIu64 "\n", c->c_connid);
 
     ret = sasl_pop_IO_layer(c->c_prfd, 0 /* do not close */);
 
diff --git a/ldap/servers/slapd/saslbind.c b/ldap/servers/slapd/saslbind.c
index 9e5d1f0..2d6fb64 100644
--- a/ldap/servers/slapd/saslbind.c
+++ b/ldap/servers/slapd/saslbind.c
@@ -929,7 +929,7 @@ void ids_sasl_check_bind(Slapi_PBlock *pb)
         Slapi_Operation *operation;
         slapi_pblock_get( pb, SLAPI_OPERATION, &operation);
         slapi_log_err(SLAPI_LOG_CONNS, "ids_sasl_check_bind",
-                        "cleaning up sasl IO conn=%" NSPRIu64 " op=%d complete=%d continuing=%d\n",
+                        "cleaning up sasl IO conn=%" PRIu64 " op=%d complete=%d continuing=%d\n",
                         pb->pb_conn->c_connid, operation->o_opid,
                         (pb->pb_conn->c_flags & CONN_FLAG_SASL_COMPLETE), continuing);
         /* reset flag */
diff --git a/ldap/servers/slapd/search.c b/ldap/servers/slapd/search.c
index 670347e..ea8b479 100644
--- a/ldap/servers/slapd/search.c
+++ b/ldap/servers/slapd/search.c
@@ -380,7 +380,7 @@ free_and_return:;
 static void log_search_access (Slapi_PBlock *pb, const char *base, int scope, const char *fstr, const char *msg)
 {
 	slapi_log_access(LDAP_DEBUG_STATS,
-					 "conn=%" NSPRIu64 " op=%d SRCH base=\"%s\" scope=%d filter=\"%s\", %s\n",
+					 "conn=%" PRIu64 " op=%d SRCH base=\"%s\" scope=%d filter=\"%s\", %s\n",
 					 pb->pb_conn->c_connid, pb->pb_op->o_opid,
 					 base, scope, fstr, msg ? msg : "");
 
diff --git a/ldap/servers/slapd/slap.h b/ldap/servers/slapd/slap.h
index 5871bf0..abfad20 100644
--- a/ldap/servers/slapd/slap.h
+++ b/ldap/servers/slapd/slap.h
@@ -72,13 +72,8 @@ static char ptokPBE[34] = "Internal (Software) Token        ";
 #include <sys/socket.h>
 #include <netinet/in.h>
 
-/* Required to get portable printf/scanf format macros */
-#ifdef HAVE_INTTYPES_H
-#include <inttypes.h>
-
-#else
-#error Need to define portable format macros such as PRIu64
-#endif /* HAVE_INTTYPES_H */
+/* Provides our int types and platform specific requirements. */
+#include <slapi_pal.h>
 
 #define LOG_INTERNAL_OP_CON_ID      "Internal"
 #define LOG_INTERNAL_OP_OP_ID       -1
diff --git a/ldap/servers/slapd/slapi-plugin.h b/ldap/servers/slapd/slapi-plugin.h
index 725fa1c..ec8917d 100644
--- a/ldap/servers/slapd/slapi-plugin.h
+++ b/ldap/servers/slapd/slapi-plugin.h
@@ -27,6 +27,9 @@
 extern "C" {
 #endif
 
+/* Provides our int types and platform specific requirements. */
+#include <slapi_pal.h>
+
 #include "prtypes.h"
 #include "ldap.h"
 #include "prprf.h"
@@ -57,17 +60,6 @@ NSPR_API(PRUint32) PR_fprintf(struct PRFileDesc* fd, const char *fmt, ...)
         ;
 #endif
 
-/* NSPR uses the print macros a bit differently than ANSI C.  We
- * need to use ll for a 64-bit integer, even when a long is 64-bit.
- */
-#if defined(HAVE_LONG_LONG) && PR_BYTES_PER_LONG == 8 && !defined(PR_ALTERNATE_INT64_TYPEDEF)
-#define NSPRIu64	"lu"
-#define NSPRI64	"l"
-#else /* just assume long long is used */
-#define NSPRIu64	"llu"
-#define NSPRI64	"ll"
-#endif
-
 /* OpenLDAP uses unsigned long for ber_tag_t and ber_len_t but mozldap uses unsigned int */
 /* use this macro for printf statements for ber_tag_t and ber_len_t */
 #if defined(USE_OPENLDAP)
diff --git a/ldap/servers/slapd/slapi-private.h b/ldap/servers/slapd/slapi-private.h
index dd180a7..0c76580 100644
--- a/ldap/servers/slapd/slapi-private.h
+++ b/ldap/servers/slapd/slapi-private.h
@@ -30,6 +30,9 @@ extern "C" {
  */
 #include "slapi-plugin-compat4.h"
 
+/* slapi platform abstraction functions. */
+#include <slapi_pal.h>
+
 /* Define our internal logging macro */
 #define slapi_log_err(level, subsystem, fmt, ...)
 #ifdef LDAP_ERROR_LOGGING
@@ -1363,26 +1366,33 @@ long long slapi_parse_duration_longlong(const char *value);
 int slapi_is_duration_valid(const char *value);
 
 /**
- * Populate the pointers with the system memory information.
- * At this time, Linux is the only "reliable" system for returning these values
- *
- * \param pagesize Will return the system page size in bytes.
- * \param pages The total number of memory pages on the system. May include swap pages depending on OS.
- * \param procpages Number of memory pages our current process is consuming. May not be accurate on all platforms as this could be the VMSize rather than the actual number of consumed pages.
- * \param availpages Number of available pages of memory on the system. Not all operating systems set this correctly.
- *
- * \return 0 on success, non-zero on failure to determine memory sizings.
+ * Possible results of a cachesize check
  */
-int util_info_sys_pages(size_t *pagesize, size_t *pages, size_t *procpages, size_t *availpages);
-
+typedef enum _util_cachesize_result {
+    /**
+     * The requested cachesize was valid and can be used.
+     */
+    UTIL_CACHESIZE_VALID = 0,
+    /**
+     * The requested cachesize may cause OOM and was reduced.
+     */
+    UTIL_CACHESIZE_REDUCED = 1,
+    /**
+     * An error occured resolving the cache size. You must stop processing.
+     */
+    UTIL_CACHESIZE_ERROR = 2,
+} util_cachesize_result;
 /**
- * Determine if the requested cachesize will exceed the system memory limits causing an out of memory condition
+ * Determine if the requested cachesize will exceed the system memory limits causing an out of memory condition. You must
+ * check the result before proceeding to correctly use the cache.
  *
+ * \param mi. The system memory infomation. You should retrieve this with spal_meminfo_get(), and destroy it after use.
  * \param cachesize. The requested allocation. If this value is greater than the memory available, this value will be REDUCED to be valid.
  *
- * \return 0 if the size is "sane". 1 if the value will cause OOM and has been REDUCED
+ * \return util_cachesize_result.
+ * \sa util_cachesize_result, spal_meminfo_get
  */
-int util_is_cachesize_sane(size_t *cachesize);
+util_cachesize_result util_is_cachesize_sane(slapi_pal_meminfo *mi, size_t *cachesize);
 
 /**
  * Retrieve the number of threads the server should run with based on this hardware.
diff --git a/ldap/servers/slapd/slapi_pal.c b/ldap/servers/slapd/slapi_pal.c
new file mode 100644
index 0000000..91576ca
--- /dev/null
+++ b/ldap/servers/slapd/slapi_pal.c
@@ -0,0 +1,311 @@
+/** BEGIN COPYRIGHT BLOCK
+ * Copyright (C) 2017 Red Hat, Inc.
+ * All rights reserved.
+ *
+ * License: GPL (version 3 or any later version).
+ * See LICENSE for details. 
+ * END COPYRIGHT BLOCK **/
+
+/*
+ * Implementation of functions to abstract from platform
+ * specific issues.
+ */
+
+/* Provide ch_malloc etc. */
+#include <slapi-plugin.h>
+/* Provide slapi_log_err macro wrapper */
+#include <slapi-private.h>
+#include <slapi_pal.h>
+
+/* Assert macros */
+#include <assert.h>
+/* Access errno */
+#include <errno.h>
+
+/* For getpagesize */
+#include <unistd.h>
+
+/* For rlimit */
+#include <sys/time.h>
+#include <sys/resource.h>
+
+#ifdef OS_solaris
+#include <sys/procfs.h>
+#endif
+
+#if defined ( hpux )
+#include <sys/pstat.h>
+#endif
+
+static int_fast32_t
+_spal_rlimit_get(int resource, uint64_t *soft_limit, uint64_t *hard_limit) {
+    struct rlimit rl = {0};
+
+    if (getrlimit(resource, &rl) != 0) {
+        int errsrv = errno;
+        slapi_log_err(SLAPI_LOG_ERR, "_spal_rlimit_mem_get", "Failed to access system resource limits %d\n", errsrv);
+        return 1;
+    }
+
+    if (rl.rlim_cur != RLIM_INFINITY) {
+        *soft_limit = (uint64_t)rl.rlim_cur;
+    }
+    if (rl.rlim_max != RLIM_INFINITY) {
+        *hard_limit = (uint64_t)rl.rlim_max;
+    }
+
+    return 0;
+}
+
+
+#ifdef LINUX
+static int_fast32_t
+_spal_uint64_t_file_get(char *name, char *prefix, uint64_t *dest) {
+    FILE *f;
+    char s[40] = {0};
+    size_t prefix_len = 0;
+
+    if (prefix != NULL) {
+        prefix_len = strlen(prefix);
+    }
+
+    /* Make sure we can fit into our buffer */
+    assert((prefix_len + 20) < 39);
+
+    f = fopen(name, "r");
+    if (!f) {    /* fopen failed */
+        int errsrv = errno;
+        slapi_log_err(SLAPI_LOG_ERR,"_spal_get_uint64_t_file", "Unable to open file \"%s\". errno=%d\n", name, errsrv);
+        return 1;
+    }
+
+    int_fast32_t retval = 0;
+    while (! feof(f)) {
+        if (!fgets(s, 39, f)) {
+            retval = 1;
+            break; /* error or eof */
+        }
+        if (feof(f)) {
+            retval = 1;
+            break;
+        }
+        if (prefix_len > 0 && strncmp(s, prefix, prefix_len) == 0) {
+            sscanf(s + prefix_len, "%"SCNu64, dest);
+            break;
+        } else if (prefix_len == 0) {
+            sscanf(s, "%"SCNu64, dest);
+            break;
+        }
+    }
+    fclose(f);
+    return retval;
+}
+
+
+
+slapi_pal_meminfo *
+spal_meminfo_get() {
+    slapi_pal_meminfo *mi = (slapi_pal_meminfo *)slapi_ch_calloc(1, sizeof(slapi_pal_meminfo));
+
+    mi->pagesize_bytes = getpagesize();
+
+    /*
+     * We have to compare values from a number of sources to ensure we have
+     * the correct result.
+     */
+
+    char f_proc_status[30] = {0};
+    sprintf(f_proc_status, "/proc/%d/status", getpid());
+    char *p_vmrss = "VmRSS:";
+    uint64_t vmrss = 0;
+
+    if (_spal_uint64_t_file_get(f_proc_status, p_vmrss, &vmrss)) {
+        slapi_log_err(SLAPI_LOG_ERR, "spal_meminfo_get", "Unable to retrieve vmrss\n");
+    }
+
+    /* vmrss is in kb, so convert to bytes */
+    vmrss = vmrss * 1024;
+
+    uint64_t rl_mem_soft = 0;
+    uint64_t rl_mem_hard = 0;
+    uint64_t rl_mem_soft_avail = 0;
+
+    if (_spal_rlimit_get(RLIMIT_AS, &rl_mem_soft, &rl_mem_hard)) {
+        slapi_log_err(SLAPI_LOG_ERR, "spal_meminfo_get", "Unable to retrieve memory rlimit\n");
+    }
+
+    if (rl_mem_soft != 0 && vmrss != 0 && rl_mem_soft > vmrss) {
+        rl_mem_soft_avail = rl_mem_soft - vmrss;
+    }
+
+    char *f_meminfo = "/proc/meminfo";
+    char *p_memtotal = "MemTotal:";
+    char *p_memavail = "MemAvailable:";
+
+    uint64_t memtotal = 0;
+    uint64_t memavail = 0;
+
+    if (_spal_uint64_t_file_get(f_meminfo, p_memtotal, &memtotal)) {
+        slapi_log_err(SLAPI_LOG_ERR, "spal_meminfo_get", "Unable to retrieve %s : %s\n", f_meminfo, p_memtotal);
+    }
+
+    if (_spal_uint64_t_file_get(f_meminfo, p_memavail, &memavail)) {
+        slapi_log_err(SLAPI_LOG_ERR, "spal_meminfo_get", "Unable to retrieve %s : %s\n", f_meminfo, p_memavail);
+    }
+
+    /* Both memtotal and memavail are in kb */
+    memtotal = memtotal * 1024;
+    memavail = memavail * 1024;
+
+    /* If it's possible, get our cgroup info */
+    uint64_t cg_mem_soft = 0;
+    uint64_t cg_mem_hard = 0;
+    uint64_t cg_mem_usage = 0;
+    uint64_t cg_mem_soft_avail = 0;
+
+    char *f_cg_soft = "/sys/fs/cgroup/memory/memory.soft_limit_in_bytes";
+    char *f_cg_hard = "/sys/fs/cgroup/memory/memory.limit_in_bytes";
+    char *f_cg_usage = "/sys/fs/cgroup/memory/memory.usage_in_bytes";
+
+    if (_spal_uint64_t_file_get(f_cg_soft, NULL, &cg_mem_soft)) {
+        slapi_log_err(SLAPI_LOG_WARNING, "spal_meminfo_get", "Unable to retrieve %s. There may be no cgroup support on this platform\n", f_cg_soft);
+    }
+
+    if (_spal_uint64_t_file_get(f_cg_hard, NULL, &cg_mem_hard)) {
+        slapi_log_err(SLAPI_LOG_WARNING, "spal_meminfo_get", "Unable to retrieve %s. There may be no cgroup support on this platform\n", f_cg_hard);
+    }
+
+    if (_spal_uint64_t_file_get(f_cg_usage, NULL, &cg_mem_usage)) {
+        slapi_log_err(SLAPI_LOG_WARNING, "spal_meminfo_get", "Unable to retrieve %s. There may be no cgroup support on this platform\n", f_cg_hard);
+    }
+
+    /*
+     * In some conditions, like docker, we only have a *hard* limit set.
+     * This obviously breaks our logic, so we need to make sure we correct this
+     */
+
+    if (cg_mem_hard != 0 && cg_mem_soft != 0 && cg_mem_hard < cg_mem_soft) {
+        /* Right, we only have a hard limit. Impose a 10% watermark. */
+        cg_mem_soft = cg_mem_hard * 0.9;
+    }
+
+    if (cg_mem_soft != 0 && cg_mem_usage != 0 && cg_mem_soft > cg_mem_usage) {
+        cg_mem_soft_avail = cg_mem_soft - cg_mem_usage;
+    }
+
+
+    /* Now, compare the values and make a choice to which is provided */
+
+    /* Process consumed memory */
+    mi->process_consumed_bytes = vmrss;
+    mi->process_consumed_pages = vmrss / mi->pagesize_bytes;
+
+    /* System Total memory */
+    /*                       If we have a memtotal, OR if no memtotal but rlimit */
+    if (rl_mem_hard != 0 &&
+            ((memtotal != 0 && rl_mem_hard < memtotal) || memtotal == 0) &&
+            ((cg_mem_hard != 0 && rl_mem_hard < cg_mem_hard) || cg_mem_hard == 0)
+        )
+    {
+        slapi_log_err(SLAPI_LOG_TRACE, "spal_meminfo_get", "system_total_bytes - using rlimit\n");
+        mi->system_total_bytes = rl_mem_hard;
+        mi->system_total_pages = rl_mem_hard / mi->pagesize_bytes;
+    } else if (cg_mem_hard != 0 && ((memtotal != 0 && cg_mem_hard < memtotal) || memtotal == 0)) {
+        slapi_log_err(SLAPI_LOG_TRACE, "spal_meminfo_get", "system_total_bytes - using cgroup\n");
+        mi->system_total_bytes = cg_mem_hard;
+        mi->system_total_pages = cg_mem_hard / mi->pagesize_bytes;
+    } else if (memtotal != 0) {
+        slapi_log_err(SLAPI_LOG_TRACE, "spal_meminfo_get", "system_total_bytes - using memtotal\n");
+        mi->system_total_bytes = memtotal;
+        mi->system_total_pages = memtotal / mi->pagesize_bytes;
+    } else {
+        slapi_log_err(SLAPI_LOG_CRIT, "spal_meminfo_get", "Unable to determine system total memory!\n");
+        spal_meminfo_destroy(mi);
+        return NULL;
+    }
+
+    /* System Available memory */
+
+    if (rl_mem_soft_avail != 0 &&
+            ((memavail != 0 && (rl_mem_soft_avail) < memavail) || memavail == 0) &&
+            ((cg_mem_soft_avail != 0 && rl_mem_soft_avail < cg_mem_soft_avail) || cg_mem_soft_avail == 0)
+        )
+    {
+        slapi_log_err(SLAPI_LOG_TRACE, "spal_meminfo_get", "system_available_bytes - using rlimit\n");
+        mi->system_available_bytes = rl_mem_soft_avail;
+        mi->system_available_pages = rl_mem_soft_avail / mi->pagesize_bytes;
+    } else if (cg_mem_soft_avail != 0 && ((memavail != 0 && (cg_mem_soft_avail) < memavail) || memavail == 0)) {
+        slapi_log_err(SLAPI_LOG_TRACE, "spal_meminfo_get", "system_available_bytes - using cgroup\n");
+        mi->system_available_bytes = cg_mem_soft_avail;
+        mi->system_available_pages = cg_mem_soft_avail / mi->pagesize_bytes;
+    } else if (memavail != 0) {
+        slapi_log_err(SLAPI_LOG_TRACE, "spal_meminfo_get", "system_available_bytes - using memavail\n");
+        mi->system_available_bytes = memavail;
+        mi->system_available_pages = memavail / mi->pagesize_bytes;
+    } else {
+        slapi_log_err(SLAPI_LOG_CRIT, "spal_meminfo_get", "Unable to determine system available memory!\n");
+        spal_meminfo_destroy(mi);
+        return NULL;
+    }
+
+    slapi_log_err(SLAPI_LOG_TRACE, "spal_meminfo_get", "{pagesize_bytes = %"PRIu64", system_total_pages = %"PRIu64", system_total_bytes = %"PRIu64", process_consumed_pages = %"PRIu64", process_consumed_bytes = %"PRIu64", system_available_pages = %"PRIu64", system_available_bytes = %"PRIu64"},\n",
+        mi->pagesize_bytes, mi->system_total_pages, mi->system_total_bytes, mi->process_consumed_pages, mi->process_consumed_bytes, mi->system_available_pages, mi->system_available_bytes);
+
+    return mi;
+}
+
+
+#endif
+
+#ifdef OS_solaris
+uint64_t
+_spal_solaris_resident_pages_get() {
+    uint64_t procpages = 0;
+    struct prpsinfo psi = {0};
+    char fn[40];
+    int fd;
+
+    sprintf(fn, "/proc/%d", getpid());
+    fd = open(fn, O_RDONLY);
+    if (fd >= 0) {
+        if (ioctl(fd, PIOCPSINFO, (void *)&psi) == 0) {
+            procpages = (uint64_t)psi.pr_size;
+        }
+        close(fd);
+    }
+    return procpages;
+}
+
+slapi_pal_meminfo *
+spal_meminfo_get() {
+    slapi_pal_meminfo *mi = (slapi_pal_meminfo *)slapi_ch_calloc(1, sizeof(slapi_pal_meminfo));
+
+    uint64_t rl_mem_soft = 0;
+    uint64_t rl_mem_hard = 0;
+
+    if (_spal_rlimit_get(RLIMIT_AS, &rl_mem_soft, &rl_mem_hard)) {
+        slapi_log_err(SLAPI_LOG_ERR, "spal_meminfo_get", "Unable to retrieve memory rlimit\n");
+    }
+
+    mi->pagesize_bytes = sysconf(_SC_PAGESIZE);
+    mi->system_total_pages = sysconf(_SC_PHYS_PAGES);
+    mi->system_total_bytes = mi->system_total_pages * mi->pagesize_bytes;
+    mi->system_available_bytes = rl_mem_soft;
+    if (rl_mem_soft != 0) {
+        mi->system_available_pages = rl_mem_soft / mi->pagesize_bytes;
+    }
+    mi->process_consumed_pages = _spal_solaris_resident_pages_get();
+    mi->process_consumed_bytes = mi->process_consumed_pages * mi->pagesize_bytes;
+
+    return mi;
+
+}
+#endif
+
+#ifdef HPUX
+#endif
+
+void
+spal_meminfo_destroy(slapi_pal_meminfo *mi) {
+    slapi_ch_free((void **)&mi);
+}
diff --git a/ldap/servers/slapd/slapi_pal.h b/ldap/servers/slapd/slapi_pal.h
new file mode 100644
index 0000000..cb61d84
--- /dev/null
+++ b/ldap/servers/slapd/slapi_pal.h
@@ -0,0 +1,62 @@
+/** BEGIN COPYRIGHT BLOCK
+ * Copyright (C) 2017 Red Hat, Inc.
+ * All rights reserved.
+ *
+ * License: GPL (version 3 or any later version).
+ * See LICENSE for details. 
+ * END COPYRIGHT BLOCK **/
+
+/*
+ * Header for the slapi platform abstraction layer.
+ *
+ * This implements a number of functions that help to provide vendor
+ * neutral requests. Candidates for this are memory, thread, disk size
+ * and other operations.
+ *
+ * Basically anywhere you see a "ifdef PLATFORM" is a candidate
+ * for this.
+ */
+
+#pragma once
+
+#include <config.h>
+
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#error Need to define portable format macros such as PRIu64
+#endif /* HAVE_INTTYPES_H */
+
+/**
+ * Structure that contains our system memory information in bytes and pages.
+ *
+ */
+typedef struct _slapi_pal_meminfo {
+    uint64_t pagesize_bytes;
+    uint64_t system_total_pages;
+    uint64_t system_total_bytes;
+    uint64_t process_consumed_pages;
+    uint64_t process_consumed_bytes;
+    /* This value may be limited by cgroup or others. */
+    uint64_t system_available_pages;
+    uint64_t system_available_bytes;
+} slapi_pal_meminfo;
+
+/**
+ * Allocate and returne a populated memory info structure. This will be NULL
+ * on error, or contain a structure populated with platform information on
+ * success. You should free this with spal_meminfo_destroy.
+ *
+ * \return slapi_pal_meminfo * pointer to structure containing data, or NULL.
+ */
+slapi_pal_meminfo * spal_meminfo_get();
+
+/**
+ * Destroy an allocated memory info structure. The caller is responsible for
+ * ensuring this is called.
+ *
+ * \param mi the allocated slapi_pal_meminfo structure from spal_meminfo_get();
+ */
+void spal_meminfo_destroy(slapi_pal_meminfo *mi);
+
+
diff --git a/ldap/servers/slapd/snmp_collator.c b/ldap/servers/slapd/snmp_collator.c
index b0c873d..21043d9 100644
--- a/ldap/servers/slapd/snmp_collator.c
+++ b/ldap/servers/slapd/snmp_collator.c
@@ -711,7 +711,7 @@ static void
 add_counter_to_value(Slapi_Entry *e, const char *type, PRUint64 countervalue)
 {
 	char value[40];
-	snprintf(value,sizeof(value),"%" NSPRIu64, countervalue);
+	snprintf(value,sizeof(value),"%" PRIu64, countervalue);
 	slapi_entry_attr_set_charptr( e, type, value);
 }
 
diff --git a/ldap/servers/slapd/unbind.c b/ldap/servers/slapd/unbind.c
index fd44249..92dd905 100644
--- a/ldap/servers/slapd/unbind.c
+++ b/ldap/servers/slapd/unbind.c
@@ -49,7 +49,7 @@ do_unbind( Slapi_PBlock *pb )
 	 *	UnBindRequest ::= NULL
 	 */
 	if ( ber_get_null( ber ) == LBER_ERROR ) {
-		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d UNBIND,"
+		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d UNBIND,"
 				" decoding error: UnBindRequest not null\n",
 				pb->pb_conn->c_connid, operation->o_opid );
 		/* LDAPv3 does not allow a response to an unbind... so just return. */
@@ -64,7 +64,7 @@ do_unbind( Slapi_PBlock *pb )
 	 * MUST ignore the criticality field of controls
 	 */
 	if ( (err = get_ldapmessage_controls_ext( pb, ber, NULL, ignore_criticality )) != 0 ) {
-		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d UNBIND,"
+		slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d UNBIND,"
 				" error processing controls - error %d (%s)\n",
 				pb->pb_conn->c_connid, operation->o_opid,
 				err, ldap_err2string( err ));
@@ -79,7 +79,7 @@ do_unbind( Slapi_PBlock *pb )
 
 	/* ONREPL - plugins should be called and passed bind dn and, possibly, other data */
 
-	slapi_log_access( LDAP_DEBUG_STATS, "conn=%" NSPRIu64 " op=%d UNBIND\n",
+	slapi_log_access( LDAP_DEBUG_STATS, "conn=%" PRIu64 " op=%d UNBIND\n",
 			pb->pb_conn->c_connid, operation->o_opid );
 
 	/* pass the unbind to all backends */
diff --git a/ldap/servers/slapd/util.c b/ldap/servers/slapd/util.c
index 48fa3c4..012e83d 100644
--- a/ldap/servers/slapd/util.c
+++ b/ldap/servers/slapd/util.c
@@ -40,20 +40,8 @@
 #define FILTER_BUF 128 /* initial buffer size for attr value */
 #define BUF_INCR 16    /* the amount to increase the FILTER_BUF once it fills up */
 
-/* Used by our util_info_sys_pages function
- *
- * platforms supported so far:
- * Solaris, Linux, Windows
- */
-#ifdef OS_solaris
-#include <sys/procfs.h>
-#endif
-#ifdef LINUX
-#include <linux/kernel.h>
-#endif
-#if defined ( hpux )
-#include <sys/pstat.h>
-#endif
+/* slapi-private contains the pal. */
+#include <slapi-private.h>
 
 static int special_filename(unsigned char c)
 {
@@ -1471,361 +1459,25 @@ slapi_uniqueIDRdnSize(void)
 	return util_uniqueidlen;
 }
 
-
-/**
- * Get the virtual memory size as defined by system rlimits.
- *
- * \return size_t bytes available
- */
-static size_t util_getvirtualmemsize(void)
-{
-    struct rlimit rl;
-    /* the maximum size of a process's total available memory, in bytes */
-    if (getrlimit(RLIMIT_AS, &rl) != 0) {
-        /* We received an error condition. There are a number of possible 
-         * reasons we have have gotten here, but most likely is EINVAL, where
-         * rlim->rlim_cur was greater than rlim->rlim_max.
-         * As a result, we should return a 0, to tell the system we can't alloc
-         * memory.
-         */
-        int errsrv = errno;
-        slapi_log_err(SLAPI_LOG_ERR,"util_getvirtualmemsize",
-                "getrlimit returned non-zero. errno=%u\n", errsrv);
-        return 0;
-    }
-    return rl.rlim_cur;
-}
-
-/* pages = number of pages of physical ram on the machine (corrected for 32-bit build on 64-bit machine).
- * procpages = pages currently used by this process (or working set size, sometimes)
- * availpages = some notion of the number of pages 'free'. Typically this number is not useful.
- */
-int util_info_sys_pages(size_t *pagesize, size_t *pages, size_t *procpages, size_t *availpages)
-{
-    if ((NULL == pagesize) || (NULL == pages) || (NULL == procpages) || (NULL == availpages)) {
-        slapi_log_err(SLAPI_LOG_ERR, "util_info_sys_pages",
-                        "Null return variables are passed.  Skip getting the system info.\n");
-        return 1;
-    }
-    *pagesize = 0;
-    *pages = 0;
-    *availpages = 0;
-    *procpages = 0;
-
-#ifdef OS_solaris
-    *pagesize = (int)sysconf(_SC_PAGESIZE);
-    *pages = (int)sysconf(_SC_PHYS_PAGES);
-    *availpages = util_getvirtualmemsize() / *pagesize;
-    /* solaris has THE most annoying way to get this info */
-    {
-        struct prpsinfo psi = {0};
-        char fn[40];
-        int fd;
-
-        sprintf(fn, "/proc/%d", getpid());
-        fd = open(fn, O_RDONLY);
-        if (fd >= 0) {
-            if (ioctl(fd, PIOCPSINFO, (void *)&psi) == 0) {
-                *procpages = psi.pr_size;
-            }
-            close(fd);
-        }
-    }
-#endif
-
-#ifdef LINUX
-    {
-        /*
-         * On linux because of the way that the virtual memory system works, we
-         * don't really need to think about other processes, or fighting them.
-         * But that's not without quirks.
-         *
-         * We are given a virtual memory space, represented by vsize (man 5 proc)
-         * This space is a "funny number". It's a best effort based system
-         * where linux instead of telling us how much memory *actually* exists
-         * for us to use, gives us a virtual memory allocation which is the
-         * value of ram + swap.... sometimes. Depends on platform.
-         *
-         * But none of these pages even exist or belong to us on the real system
-         * until will malloc them AND write a non-zero to them.
-         *
-         * The biggest issue with this is that vsize does NOT consider the
-         * effect other processes have on the system. So a process can malloc
-         * 2 Gig from the host, and our vsize doesn't reflect that until we
-         * suddenly can't malloc anything.
-         *
-         * We can see exactly what we are using inside of the vmm by
-         * looking at rss (man 5 proc). This shows us the current actual
-         * allocation of memory we are using. This is a good thing.
-         *
-         * We obviously don't want to have any pages in swap, but sometimes we
-         * can't help that: And there is also no guarantee that while we have
-         * X bytes in vsize, that we can even allocate any of them. Plus, we
-         * don't know if we are about to allocate to swap or not .... or get us
-         * killed in a blaze of oom glory.
-         *
-         * So there are now two strategies avaliable in this function.
-         * The first is to blindly accept what the VMM tells us about vsize
-         * while we hope and pray that we don't get nailed because we used
-         * too much.
-         *
-         * The other is a more conservative approach: We check vsize from
-         * proc/pid/status, and we check /proc/meminfo for freemem
-         * Which ever value is "lower" is the upper bound on pages we could
-         * potentially allocate: generally, this will be MemAvailable.
-         */
-
-        size_t freesize = 0;
-        size_t rlimsize = 0;
-
-        *pagesize = getpagesize();
-
-        /* Get the amount of freeram, rss */
-
-        FILE *f;
-        char fn[40], s[80];
-
-        sprintf(fn, "/proc/%d/status", getpid());
-        f = fopen(fn, "r");
-        if (!f) {    /* fopen failed */
-            /* We should probably make noise here! */
-            int errsrv = errno;
-            slapi_log_err(SLAPI_LOG_ERR,"util_info_sys_pages", "Unable to open file /proc/%d/status. errno=%u\n", getpid(), errsrv);
-            return 1;
-        }
-        while (! feof(f)) {
-            if (!fgets(s, 79, f)) {
-                break; /* error or eof */
-            }
-            if (feof(f)) {
-                break;
-            }
-            /* VmRSS shows us what we are ACTUALLY using for proc pages
-             * Rather than "funny" pages.
-             */
-            if (strncmp(s, "VmRSS:", 6) == 0) {
-                sscanf(s+6, "%lu", (long unsigned int *)procpages);
-            }
-        }
-        fclose(f);
-
-        FILE *fm;
-        char *fmn = "/proc/meminfo";
-        fm = fopen(fmn, "r");
-        if (!fm) {
-            int errsrv = errno;
-            slapi_log_err(SLAPI_LOG_ERR,"util_info_sys_pages", "Unable to open file /proc/meminfo. errno=%u\n", errsrv);
-            return 1;
-        }
-        while (! feof(fm)) {
-            if (!fgets(s, 79, fm)) {
-                break; /* error or eof */
-            }
-            if (feof(fm)) {
-                break;
-            }
-            if (strncmp(s, "MemTotal:", 9) == 0) {
-                sscanf(s+9, "%lu", (long unsigned int *)pages);
-            }
-            if (strncmp(s, "MemAvailable:", 13) == 0) {
-                sscanf(s+13, "%lu", (long unsigned int *)&freesize);
-            }
-        }
-        fclose(fm);
-
-
-        *pages /= (*pagesize / 1024);
-        freesize /= (*pagesize / 1024);
-        /* procpages is now in kb not pages... */
-        *procpages /= (*pagesize / 1024);
-
-        rlimsize = util_getvirtualmemsize();
-        /* On a 64 bit system, this is uint64 max, but on 32 it's -1 */
-        /* Either way, we should be ignoring it at this point if it's infinite */
-        if (rlimsize != RLIM_INFINITY) {
-            /* This is in bytes, make it pages  */
-            rlimsize = rlimsize / *pagesize;
-        }
-
-        /* Pages is the total ram on the system. */
-        slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "pages=%lu, \n", 
-            (unsigned long) *pages);
-        slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "using pages for pages \n");
-
-        /* Availpages is how much we *could* alloc. We should take the smallest:
-         * - pages
-         * - getrlimit (availpages)
-         * - freesize
-         */
-        if (rlimsize == RLIM_INFINITY) {
-            slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "pages=%lu, getrlim=RLIM_INFINITY, freesize=%lu\n",
-                (unsigned long)*pages, (unsigned long)freesize);
-        } else {
-            slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "pages=%lu, getrlim=%lu, freesize=%lu\n",
-                (unsigned long)*pages, (unsigned long)*availpages, (unsigned long)freesize);
-        }
-
-        if (rlimsize != RLIM_INFINITY && rlimsize < freesize && rlimsize < *pages && rlimsize > 0) {
-            slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "using getrlim for availpages \n");
-            *availpages = rlimsize;
-        } else if (freesize < *pages && freesize > 0) {
-            slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "using freesize for availpages \n");
-            *availpages = freesize;
-        } else {
-            slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "using pages for availpages \n");
-            *availpages = *pages;
-        }
-
-    }
-#endif /* linux */
-
-
-
-#if defined ( hpux )
-    {
-        struct pst_static pst;
-        int rval = pstat_getstatic(&pst, sizeof(pst), (size_t)1, 0);
-        if (rval < 0) {   /* pstat_getstatic failed */
-            return 1;
-        }
-        *pagesize = pst.page_size;
-        *pages = pst.physical_memory;
-        *availpages = util_getvirtualmemsize() / *pagesize;
-        if (procpages)
-        {
-#define BURST (size_t)32        /* get BURST proc info at one time... */
-            struct pst_status psts[BURST];
-            int i, count;
-            int idx = 0; /* index within the context */
-            int mypid = getpid();
-
-            *procpages = 0;
-            /* loop until count == 0, will occur all have been returned */
-            while ((count = pstat_getproc(psts, sizeof(psts[0]), BURST, idx)) > 0) {
-                /* got count (max of BURST) this time.  process them */
-                for (i = 0; i < count; i++) {
-                    if (psts[i].pst_pid == mypid)
-                    {
-                        *procpages = (size_t)(psts[i].pst_dsize + psts[i].pst_tsize + psts[i].pst_ssize);
-                        break;
-                    }
-                }
-                if (i < count)
-                    break;
-
-                /*
-                 * now go back and do it again, using the next index after
-                 * the current 'burst'
-                 */
-                idx = psts[count-1].pst_idx + 1;
-            }
-        }
-    }
-#endif
-    /* If this is a 32-bit build, it might be running on a 64-bit machine,
-     * in which case, if the box has tons of ram, we can end up telling 
-     * the auto cache code to use more memory than the process can address.
-     * so we cap the number returned here.
-     */
-#if defined(__LP64__) || defined (_LP64)
-#else
-    {    
-#define GIGABYTE (1024*1024*1024)
-        size_t one_gig_pages = GIGABYTE / *pagesize;
-        if (*pages > (2 * one_gig_pages) ) {
-            slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages",
-                    "More than 2Gbytes physical memory detected. Since this is a 32-bit process, truncating memory size used for auto cache calculations to 2Gbytes\n");
-            *pages = (2 * one_gig_pages);
-        }
-    }
-#endif
-
-    /* This is stupid. If you set %u to %zu to print a size_t, you get literal %zu in your logs 
-     * So do the filthy cast instead.
-     */
-    slapi_log_err(SLAPI_LOG_TRACE,"util_info_sys_pages", "USING pages=%lu, procpages=%lu, availpages=%lu \n", 
-        (unsigned long)*pages, (unsigned long)*procpages, (unsigned long)*availpages);
-    return 0;
-
-}
-
-int util_is_cachesize_sane(size_t *cachesize)
+util_cachesize_result
+util_is_cachesize_sane(slapi_pal_meminfo *mi, uint64_t *cachesize)
 {
-    size_t pages = 0;
-    size_t pagesize = 0;
-    size_t procpages = 0;
-    size_t availpages = 0;
-
-    size_t cachepages = 0;
-
-    int issane = 1;
-
-    if (util_info_sys_pages(&pagesize, &pages, &procpages, &availpages) != 0) {
-        goto out;
-    }
-#ifdef LINUX
-    /* Linux we calculate availpages correctly, so USE IT */
-    if (!pagesize || !availpages) {
-        goto out;
-    }
-#else
-    if (!pagesize || !pages) {
-        goto out;
+    /* Check we have a valid meminfo struct */
+    if (mi->system_available_bytes == 0) {
+        slapi_log_err(SLAPI_LOG_CRIT, "util_is_cachesize_sane", "Invalid system memory info, can not proceed.");
+        return UTIL_CACHESIZE_ERROR;
     }
-#endif
-    /* do nothing when we can't get the avail mem */
-
-
-    /* If the requested cache size is larger than the remaining physical memory
-     * after the current working set size for this process has been subtracted,
-     * then we say that's insane and try to correct.
-     */
-
-    cachepages = *cachesize / pagesize;
-    slapi_log_err(SLAPI_LOG_TRACE,"util_is_cachesize_sane", "cachesize=%lu / pagesize=%lu \n",
-        (unsigned long)*cachesize,(unsigned long)pagesize);
-
-#ifdef LINUX
-    /* Linux we calculate availpages correctly, so USE IT */
-    issane = (int)(cachepages <= availpages);
-    slapi_log_err(SLAPI_LOG_TRACE,"util_is_cachesize_sane", "cachepages=%lu <= availpages=%lu\n",
-        (unsigned long)cachepages,(unsigned long)availpages);
 
-    if (!issane) {
+    slapi_log_err(SLAPI_LOG_TRACE, "util_is_cachesize_sane", "Available bytes %"PRIu64", requested bytes %"PRIu64"\n", mi->system_available_bytes, *cachesize);
+    if (*cachesize > mi->system_available_bytes) {
         /* Since we are ask for more than what's available, we give 3/4 of the remaining.
          * the remaining system mem to the cachesize instead, and log a warning
          */
-        *cachesize = (size_t)((availpages * 0.75 ) * pagesize);
-        /* These are now trace warnings, because it was to confusing to log this *then* kill the request anyway.
-         * Instead, we will let the caller worry about the notification, and we'll just use this in debugging and tracing.
-         */
-        slapi_log_err(SLAPI_LOG_TRACE, "util_is_cachesize_sane", 
-                "Available pages %lu, requested pages %lu, pagesize %lu\n", (unsigned long)availpages, (unsigned long)cachepages, (unsigned long)pagesize);
-        slapi_log_err(SLAPI_LOG_TRACE, "util_is_cachesize_sane",
-        		"WARNING adjusted cachesize to %lu\n", (unsigned long)*cachesize);
-    }
-#else
-    size_t freepages = 0;
-    freepages = pages - procpages;
-    slapi_log_err(SLAPI_LOG_TRACE,"util_is_cachesize_sane", "pages=%lu - procpages=%lu\n",
-        (unsigned long)pages,(unsigned long)procpages);
-
-    issane = (int)(cachepages <= freepages);
-    slapi_log_err(SLAPI_LOG_TRACE,"util_is_cachesize_sane", "cachepages=%lu <= freepages=%lu\n",
-        (unsigned long)cachepages,(unsigned long)freepages);
-
-    if (!issane) {
-        *cachesize = (size_t)((pages - procpages) * pagesize);
-        slapi_log_err(SLAPI_LOG_WARNING, "util_is_cachesize_sane", "WARNING adjusted cachesize to %lu\n",
-            (unsigned long )*cachesize);
+        *cachesize = (mi->system_available_bytes * 0.75);
+        slapi_log_err(SLAPI_LOG_TRACE, "util_is_cachesize_sane", "Adjusted cachesize to %"PRIu64"\n", *cachesize);
+        return UTIL_CACHESIZE_REDUCED;
     }
-#endif
-out:
-    if (!issane) {
-        slapi_log_err(SLAPI_LOG_TRACE,"util_is_cachesize_sane", "WARNING: Cachesize not sane \n");
-    }
-
-    return issane;
+    return UTIL_CACHESIZE_VALID;
 }
 
 long
diff --git a/test/libslapd/spal/meminfo.c b/test/libslapd/spal/meminfo.c
new file mode 100644
index 0000000..776141a
--- /dev/null
+++ b/test/libslapd/spal/meminfo.c
@@ -0,0 +1,54 @@
+/** BEGIN COPYRIGHT BLOCK
+ * Copyright (C) 2017 Red Hat, Inc.
+ * All rights reserved.
+ *
+ * License: GPL (version 3 or any later version).
+ * See LICENSE for details.
+ * END COPYRIGHT BLOCK **/
+
+#include "../../test_slapd.h"
+
+#include <slapi_pal.h>
+#include <slapi-private.h>
+
+/*
+ * Assert that our meminfo interface in slapi_pal works.
+ */
+
+void
+test_libslapd_pal_meminfo(void **state __attribute__((unused))) {
+    slapi_pal_meminfo *mi = spal_meminfo_get();
+    assert_true(mi->pagesize_bytes > 0);
+    assert_true(mi->system_total_pages > 0);
+    assert_true(mi->system_total_bytes > 0);
+    assert_true(mi->process_consumed_pages > 0);
+    assert_true(mi->process_consumed_bytes > 0);
+    assert_true(mi->system_available_pages > 0);
+    assert_true(mi->system_available_bytes > 0);
+    spal_meminfo_destroy(mi);
+}
+
+void
+test_libslapd_util_cachesane(void **state __attribute__((unused))) {
+    slapi_pal_meminfo *mi = spal_meminfo_get();
+    uint64_t request = 0;
+    mi->system_available_bytes = 0;
+    assert_true(util_is_cachesize_sane(mi, &request) == UTIL_CACHESIZE_ERROR);
+
+    // Set the values to known quantities
+    request = 50000;
+    mi->system_available_bytes = 99999;
+    assert_true(util_is_cachesize_sane(mi, &request) == UTIL_CACHESIZE_VALID);
+
+    request = 99999;
+    assert_true(util_is_cachesize_sane(mi, &request) == UTIL_CACHESIZE_VALID);
+
+    request = 100000;
+    assert_true(util_is_cachesize_sane(mi, &request) == UTIL_CACHESIZE_REDUCED);
+    assert_true(request <= 75000);
+
+    spal_meminfo_destroy(mi);
+}
+
+
+
diff --git a/test/libslapd/test.c b/test/libslapd/test.c
index 6e1171a..6fa7996 100644
--- a/test/libslapd/test.c
+++ b/test/libslapd/test.c
@@ -26,6 +26,8 @@ run_libslapd_tests (void) {
         cmocka_unit_test(test_libslapd_operation_v3c_target_spec),
         cmocka_unit_test(test_libslapd_counters_atomic_usage),
         cmocka_unit_test(test_libslapd_counters_atomic_overflow),
+        cmocka_unit_test(test_libslapd_pal_meminfo),
+        cmocka_unit_test(test_libslapd_util_cachesane),
     };
     return cmocka_run_group_tests(tests, NULL, NULL);
 }
diff --git a/test/test_slapd.h b/test/test_slapd.h
index b8f1aba..50de11b 100644
--- a/test/test_slapd.h
+++ b/test/test_slapd.h
@@ -42,3 +42,8 @@ void test_libslapd_operation_v3c_target_spec(void **state);
 void test_libslapd_counters_atomic_usage(void **state);
 void test_libslapd_counters_atomic_overflow(void **state);
 
+/* libslapd-pal-meminfo */
+
+void test_libslapd_pal_meminfo(void **state);
+void test_libslapd_util_cachesane(void **state);
+
-- 
2.9.3

