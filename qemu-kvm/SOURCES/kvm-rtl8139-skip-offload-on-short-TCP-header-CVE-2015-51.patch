From 62f1eddbc1e0261ff18e5a0dd0e0db23a93e8d4e Mon Sep 17 00:00:00 2001
From: Stefan Hajnoczi <stefanha@redhat.com>
Date: Fri, 31 Jul 2015 15:59:47 +0200
Subject: [PATCH 12/13] rtl8139: skip offload on short TCP header
 (CVE-2015-5165)

Message-id: <1438358388-10575-7-git-send-email-stefanha@redhat.com>
Patchwork-id: 67241
O-Subject: [RHEL-7.1.z qemu-kvm EMBARGOED PATCH 6/7] rtl8139: skip offload on short TCP header (CVE-2015-5165)
Bugzilla: 1248766
RH-Acked-by: Dr. David Alan Gilbert <dgilbert@redhat.com>
RH-Acked-by: Xiao Wang <jasowang@redhat.com>
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>

TCP Large Segment Offload accesses the TCP header in the packet.  If the
packet is too short we must not attempt to access header fields:

  tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);
  int tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);

Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
Signed-off-by: Miroslav Rezanina <mrezanin@redhat.com>
---
 hw/net/rtl8139.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/hw/net/rtl8139.c b/hw/net/rtl8139.c
index 61bc34c..c9bf454 100644
--- a/hw/net/rtl8139.c
+++ b/hw/net/rtl8139.c
@@ -2202,6 +2202,11 @@ static int rtl8139_cplus_transmit_one(RTL8139State *s)
 
             if ((txdw0 & CP_TX_LGSEN) && ip_protocol == IP_PROTO_TCP)
             {
+                /* Large enough for the TCP header? */
+                if (ip_data_len < sizeof(tcp_header)) {
+                    goto skip_offload;
+                }
+
                 int large_send_mss = (txdw0 >> 16) & CP_TC_LGSEN_MSS_MASK;
 
                 DPRINTF("+++ C+ mode offloaded task TSO MTU=%d IP data %d "
-- 
1.8.3.1

