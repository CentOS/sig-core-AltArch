commit 2b49317b4f237ea5f648d8b958f96cd03fcabc7d
Author: philippe <philippe@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date:   Mon Nov 28 19:34:06 2016 +0000

    Fix 373046 - Stacks registered by core are never deregistered
    
    
    git-svn-id: svn://svn.valgrind.org/valgrind/trunk@16159 a5019735-40e9-0310-863c-91ae7b9d1cf9

diff --git a/coregrind/m_scheduler/scheduler.c b/coregrind/m_scheduler/scheduler.c
index 0363898..49f51d6 100644
--- a/coregrind/m_scheduler/scheduler.c
+++ b/coregrind/m_scheduler/scheduler.c
@@ -488,6 +488,7 @@ static void os_state_clear(ThreadState *tst)
 {
    tst->os_state.lwpid       = 0;
    tst->os_state.threadgroup = 0;
+   tst->os_state.stk_id = NULL_STK_ID;
 #  if defined(VGO_linux)
    /* no other fields to clear */
 #  elif defined(VGO_darwin)
@@ -504,7 +505,6 @@ static void os_state_clear(ThreadState *tst)
 #  if defined(VGP_x86_solaris)
    tst->os_state.thrptr = 0;
 #  endif
-   tst->os_state.stk_id = (UWord)-1;
    tst->os_state.ustack = NULL;
    tst->os_state.in_door_return = False;
    tst->os_state.door_return_procedure = 0;
diff --git a/coregrind/m_syswrap/syswrap-generic.c b/coregrind/m_syswrap/syswrap-generic.c
index 6ef6a90..28972ae 100644
--- a/coregrind/m_syswrap/syswrap-generic.c
+++ b/coregrind/m_syswrap/syswrap-generic.c
@@ -84,11 +84,14 @@ void ML_(guess_and_register_stack) (Addr sp, ThreadState* tst)
       tst->client_stack_highest_byte = (Addr)VG_PGROUNDUP(sp)-1;
       tst->client_stack_szB = tst->client_stack_highest_byte - seg->start + 1;
 
-      VG_(register_stack)(seg->start, tst->client_stack_highest_byte);
+      tst->os_state.stk_id 
+         = VG_(register_stack)(seg->start, tst->client_stack_highest_byte);
 
       if (debug)
-	 VG_(printf)("tid %u: guessed client stack range [%#lx-%#lx]\n",
-		     tst->tid, seg->start, tst->client_stack_highest_byte);
+	 VG_(printf)("tid %u: guessed client stack range [%#lx-%#lx]"
+                     " as stk_id %lu\n",
+		     tst->tid, seg->start, tst->client_stack_highest_byte,
+                     tst->os_state.stk_id);
    } else {
       VG_(message)(Vg_UserMsg,
                    "!? New thread %u starts with SP(%#lx) unmapped\n",
diff --git a/coregrind/m_syswrap/syswrap-linux.c b/coregrind/m_syswrap/syswrap-linux.c
index af10b92..725ad78 100644
--- a/coregrind/m_syswrap/syswrap-linux.c
+++ b/coregrind/m_syswrap/syswrap-linux.c
@@ -52,6 +52,7 @@
 #include "pub_core_options.h"
 #include "pub_core_scheduler.h"
 #include "pub_core_signals.h"
+#include "pub_core_stacks.h"
 #include "pub_core_syscall.h"
 #include "pub_core_syswrap.h"
 #include "pub_core_inner.h"
@@ -162,6 +163,10 @@ static void run_a_thread_NORETURN ( Word tidW )
    c = VG_(count_living_threads)();
    vg_assert(c >= 1); /* stay sane */
 
+   /* Deregister thread's stack. */
+   if (tst->os_state.stk_id != NULL_STK_ID)
+      VG_(deregister_stack)(tst->os_state.stk_id);
+
    // Tell the tool this thread is exiting
    VG_TRACK( pre_thread_ll_exit, tid );
 
diff --git a/coregrind/pub_core_threadstate.h b/coregrind/pub_core_threadstate.h
index f3d956c..3307e75 100644
--- a/coregrind/pub_core_threadstate.h
+++ b/coregrind/pub_core_threadstate.h
@@ -114,6 +114,8 @@ typedef
    ThreadArchState;
 
 
+#define NULL_STK_ID (~(UWord)0)
+
 /* OS-specific thread state.  IMPORTANT: if you add fields to this,
    you _must_ add code to os_state_clear() to initialise those
    fields. */
@@ -129,6 +131,12 @@ typedef
       Addr valgrind_stack_base;    // Valgrind's stack (VgStack*)
       Addr valgrind_stack_init_SP; // starting value for SP
 
+      /* Client stack is registered as stk_id (on linux/darwin, by
+         ML_(guess_and_register_stack)).
+         Stack id NULL_STK_ID means that the user stack is not (yet)
+         registered. */
+      UWord stk_id;
+
       /* exit details */
       Word exitcode; // in the case of exitgroup, set by someone else
       Int  fatalsig; // fatal signal
@@ -281,10 +289,6 @@ typedef
          the 64-bit offset associated with a %fs value of zero. */
 #     endif
 
-      /* Stack id (value (UWord)(-1) means that there is no stack). This
-         tracks a stack that is set in restore_stack(). */
-      UWord stk_id;
-
       /* Simulation of the kernel's lwp->lwp_ustack. Set in the PRE wrapper
          of the getsetcontext syscall, for SETUSTACK. Used in
          VG_(save_context)(), VG_(restore_context)() and
