commit c7bcd1f2ee2d466fb556bfc2b33c5ab039b0898d
Author: sewardj <sewardj@a5019735-40e9-0310-863c-91ae7b9d1cf9>
Date:   Fri Jan 20 09:58:15 2017 +0000

    x86-linux: Initialize x86 system GDT on first use.  Bug 344139 comment 3.
    Patch from Sebastian Lackner, sebastian@fds-team.de.
    
    
    git-svn-id: svn://svn.valgrind.org/valgrind/trunk@16204 a5019735-40e9-0310-863c-91ae7b9d1cf9

diff --git a/coregrind/m_syswrap/syswrap-x86-linux.c b/coregrind/m_syswrap/syswrap-x86-linux.c
index f8c4eb4..2f879d8 100644
--- a/coregrind/m_syswrap/syswrap-x86-linux.c
+++ b/coregrind/m_syswrap/syswrap-x86-linux.c
@@ -294,11 +294,37 @@ void translate_to_hw_format ( /* IN  */ vki_modify_ldt_t* inn,
    out->LdtEnt.Words.word2 = entry_2;
 }
 
-/* Create a zeroed-out GDT. */
-static VexGuestX86SegDescr* alloc_zeroed_x86_GDT ( void )
+/* Create initial GDT. */
+static VexGuestX86SegDescr* alloc_system_x86_GDT ( void )
 {
    Int nbytes = VEX_GUEST_X86_GDT_NENT * sizeof(VexGuestX86SegDescr);
-   return VG_(calloc)("di.syswrap-x86.azxG.1", nbytes, 1);
+   VexGuestX86SegDescr* gdt = VG_(calloc)("di.syswrap-x86.azxG.1", nbytes, 1);
+   vki_modify_ldt_t info;
+   UShort seg;
+
+   VG_(memset)(&info, 0, sizeof(info));
+   info.entry_number    = 0;
+   info.base_addr       = 0;
+   info.limit           = 0xfffff;
+   info.seg_32bit       = 1;
+   info.contents        = 0;
+   info.read_exec_only  = 0;
+   info.limit_in_pages  = 1;
+   info.seg_not_present = 0;
+   info.useable         = 0;
+   info.reserved        = 0;
+
+   asm volatile("movw %%ds, %0" : : "m" (seg));
+   if (!(seg & 4)) translate_to_hw_format(&info, &gdt[seg >> 3], 0);
+   asm volatile("movw %%ss, %0" : : "m" (seg));
+   if (!(seg & 4)) translate_to_hw_format(&info, &gdt[seg >> 3], 0);
+
+   info.contents        = 2;
+
+   asm volatile("movw %%cs, %0" : : "m" (seg));
+   if (!(seg & 4)) translate_to_hw_format(&info, &gdt[seg >> 3], 0);
+
+   return gdt;
 }
 
 /* Create a zeroed-out LDT. */
@@ -505,7 +531,7 @@ SysRes ML_(x86_sys_set_thread_area) ( ThreadId tid, vki_modify_ldt_t* info )
 
    /* If the thread doesn't have a GDT, allocate it now. */
    if (!gdt) {
-      gdt = alloc_zeroed_x86_GDT();
+      gdt = alloc_system_x86_GDT();
       VG_(threads)[tid].arch.vex.guest_GDT = (HWord)gdt;
    }
 
@@ -564,7 +590,7 @@ static SysRes sys_get_thread_area ( ThreadId tid, vki_modify_ldt_t* info )
 
    /* If the thread doesn't have a GDT, allocate it now. */
    if (!gdt) {
-      gdt = alloc_zeroed_x86_GDT();
+      gdt = alloc_system_x86_GDT();
       VG_(threads)[tid].arch.vex.guest_GDT = (HWord)gdt;
    }
 
@@ -616,7 +642,7 @@ void ML_(x86_setup_LDT_GDT) ( /*OUT*/ ThreadArchState *child,
    child->vex.guest_GDT = (HWord)NULL;
 
    if (parent->vex.guest_GDT != (HWord)NULL) {
-      child->vex.guest_GDT = (HWord)alloc_zeroed_x86_GDT();
+      child->vex.guest_GDT = (HWord)alloc_system_x86_GDT();
       copy_GDT_from_to( (VexGuestX86SegDescr*)parent->vex.guest_GDT,
                         (VexGuestX86SegDescr*)child->vex.guest_GDT );
    }
commit 5f4041b376f7465cd108ad4d1696b0b8a603a175
Author: sewardj <sewardj@8f6e269a-dfd6-0310-a8e1-e2731360e62c>
Date:   Fri Jan 20 10:01:42 2017 +0000

    x86: Recognize the SS segment prefix on x86.  Bug 344139 comment 4.
    Patch from Sebastian Lackner, sebastian@fds-team.de.
    
    
    git-svn-id: svn://svn.valgrind.org/vex/trunk@3299 8f6e269a-dfd6-0310-a8e1-e2731360e62c

diff --git a/VEX/priv/guest_x86_toIR.c b/VEX/priv/guest_x86_toIR.c
index de09d3a..234d68e 100644
--- a/VEX/priv/guest_x86_toIR.c
+++ b/VEX/priv/guest_x86_toIR.c
@@ -1409,6 +1409,7 @@ const HChar* sorbTxt ( UChar sorb )
       case 0x26: return "%es:";
       case 0x64: return "%fs:";
       case 0x65: return "%gs:";
+      case 0x36: return "%ss:";
       default: vpanic("sorbTxt(x86,guest)");
    }
 }
@@ -1433,6 +1434,7 @@ IRExpr* handleSegOverride ( UChar sorb, IRExpr* virtual )
       case 0x26: sreg = R_ES; break;
       case 0x64: sreg = R_FS; break;
       case 0x65: sreg = R_GS; break;
+      case 0x36: sreg = R_SS; break;
       default: vpanic("handleSegOverride(x86,guest)");
    }
 
@@ -8101,7 +8103,7 @@ DisResult disInstr_X86_WRK (
    Int sz = 4;
 
    /* sorb holds the segment-override-prefix byte, if any.  Zero if no
-      prefix has been seen, else one of {0x26, 0x3E, 0x64, 0x65}
+      prefix has been seen, else one of {0x26, 0x36, 0x3E, 0x64, 0x65}
       indicating the prefix.  */
    UChar sorb = 0;
 
@@ -8255,6 +8257,7 @@ DisResult disInstr_X86_WRK (
          case 0x26: /* %ES: */
          case 0x64: /* %FS: */
          case 0x65: /* %GS: */
+         case 0x36: /* %SS: */
             if (sorb != 0) 
                goto decode_failure; /* only one seg override allowed */
             sorb = pre;
@@ -8274,9 +8277,6 @@ DisResult disInstr_X86_WRK (
             }
             break;
          }
-         case 0x36: /* %SS: */
-            /* SS override cases are not handled */
-            goto decode_failure;
          default: 
             goto not_a_prefix;
       }
